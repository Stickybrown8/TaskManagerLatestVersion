<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chat GPT-4.1 RAG</title>
  <style>
    /* Reset et base */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 250px;
      background: #fff;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .new-chat-btn {
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px;
      margin: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .new-chat-btn:hover {
      background: #218838;
    }

    .conversation-list {
      flex: 1;
      overflow-y: auto;
    }

    .conversation-item {
      padding: 12px 15px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .conversation-item:hover {
      background: #f5f5f5;
    }

    .conversation-item.active {
      background: #e9ecef;
    }

    .conversation-title {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .conversation-menu {
      display: none;
      cursor: pointer;
      padding: 5px;
      color: #6c757d;
    }

    .conversation-item:hover .conversation-menu {
      display: block;
    }

    .menu-dropdown {
      position: absolute;
      right: 10px;
      top: 35px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 10;
      display: none;
    }

    .menu-dropdown.show {
      display: block;
    }

    .menu-item {
      padding: 8px 15px;
      cursor: pointer;
    }

    .menu-item:hover {
      background: #f5f5f5;
    }

    /* Main content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    .chat-header {
      padding: 15px 20px;
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      font-size: 18px;
      font-weight: bold;
    }

    /* Chat container */
    #chat {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background: #fff;
    }

    .message-container {
      display: flex;
      margin-bottom: 10px;
      animation: fadeIn 0.3s;
    }

    .message-container.user {
      justify-content: flex-end;
    }

    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 18px;
      line-height: 1.3;
      overflow-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user {
      background: #007bff;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .message.bot {
      background: #f1f0f0;
      color: #222;
      border-bottom-left-radius: 4px;
      font-size: 15px;
      line-height: 1.3;
    }

    .message.bot p {
      margin: 2px 0;
      line-height: 1.3;
    }

    .message.bot ul,
    .message.bot ol {
      margin: 2px 0 2px 14px;
      padding-left: 6px;
    }

    .message.bot li {
      margin-bottom: 1px;
      line-height: 1.3;
    }

    .message.bot h1,
    .message.bot h2,
    .message.bot h3 {
      color: #0366d6;
      margin-top: 5px;
      margin-bottom: 3px;
      border-bottom: 1px solid #eaecef;
      padding-bottom: 2px;
      line-height: 1.2;
    }

    .message.bot h4,
    .message.bot h5,
    .message.bot h6 {
      margin-top: 4px;
      margin-bottom: 2px;
      line-height: 1.2;
    }

    /* Styles spécifiques pour les blocs de code */
    .code-block {
      position: relative;
      margin: 5px 0;
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      overflow: hidden;
    }

    .language-indicator {
      position: absolute;
      top: 0;
      left: 0;
      background: #e0e0e0;
      color: #333;
      font-size: 12px;
      padding: 2px 8px;
      border-bottom-right-radius: 6px;
    }

    .copy-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 3px 8px;
      font-size: 12px;
      cursor: pointer;
      z-index: 5;
      transition: background-color 0.2s;
    }

    .copy-btn:hover {
      opacity: 1;
      background: #5a6268;
    }

    pre {
      background: #f8f9fa;
      padding: 8px 12px;
      margin: 0;
      overflow-x: auto;
    }

    code {
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 13px;
      white-space: pre !important;
      tab-size: 4;
    }

    .message.bot pre {
      background-color: #f6f8fa;
      border-radius: 5px;
      margin: 4px 0;
    }

    .message.bot code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 85%;
    }

    .typing {
      font-style: italic;
      opacity: 0.7;
      background: #f1f0f0;
      color: #333;
    }

    /* Images dans le chat */
    .chat-image {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      margin: 8px 0;
    }

    /* Contrôles d'input */
    .input-container {
      position: relative;
      background: #fff;
      border-top: 1px solid #e0e0e0;
      padding: 15px 20px;
    }

    /* Nouveau style pour le sélecteur de modèle */
    .model-selector-container {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
      position: relative;
    }

    .model-selector {
      width: 100%;
      max-width: 450px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px 15px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .model-selector-label {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .model-title {
      font-size: 15px;
    }

    .model-info {
      font-size: 12px;
      color: #666;
      font-weight: normal;
    }

    .model-options {
      display: flex;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #ddd;
    }

    .model-option {
      flex: 1;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
      position: relative;
      overflow: hidden;
    }

    .model-option.gpt-4-1 {
      background-color: #f0f7ff;
      color: #0366d6;
      border-right: 1px solid #ddd;
    }

    .model-option.gpt-4-1.selected {
      background-color: #0366d6;
      color: white;
    }

    .model-option.gpt-4o {
      background-color: #fff5e6;
      color: #e67700;
    }

    .model-option.gpt-4o.selected {
      background-color: #e67700;
      color: white;
    }

    .model-option-badge {
      position: absolute;
      top: 0;
      right: 0;
      background: #28a745;
      color: white;
      font-size: 9px;
      padding: 2px 5px;
      border-bottom-left-radius: 4px;
    }

    /* Zone de saisie améliorée */
    .input-wrapper {
      position: relative;
      max-height: 300px;
      /* Hauteur maximum pour ne pas trop envahir l'écran */
      min-height: 60px;
      /* Hauteur minimum pour avoir une bonne taille initiale */
      overflow-y: auto;
      /* Permet d'avoir une barre de défilement si besoin */
      margin-bottom: 10px;
      border-radius: 18px;
      border: 1px solid #ced4da;
      background: white;
    }

    #input {
      width: 100%;
      min-height: 60px;
      max-height: none;
      padding: 15px;
      padding-right: 50px;
      /* Espace pour le bouton d'envoi */
      border: none;
      border-radius: 18px;
      font-size: 15px;
      line-height: 1.5;
      resize: none;
      outline: none;
      overflow-y: hidden;
      /* Cache la barre de défilement de la textarea */
      font-family: Arial, sans-serif;
    }

    #send {
      position: absolute;
      right: 15px;
      bottom: 15px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 2;
      /* Au-dessus de la textarea */
    }

    #send:hover {
      background: #218838;
    }

    #send:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .send-icon {
      width: 20px;
      height: 20px;
    }

    /* Image preview */
    .image-preview {
      display: none;
      margin-top: 10px;
      position: relative;
    }

    .image-preview img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
    }

    .image-preview button {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(220, 53, 69, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .paste-info {
      margin-top: 8px;
      color: #6c757d;
      font-size: 12px;
      text-align: center;
    }

    /* File tree - STYLE AMÉLIORÉ */
    .file-tree-container {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      overflow: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 1000;
    }

    .file-tree-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .file-tree-title {
      font-size: 18px;
      font-weight: bold;
    }

    .file-tree-actions {
      display: flex;
      gap: 10px;
    }

    .file-tree-close {
      font-size: 20px;
      background: none;
      border: none;
      cursor: pointer;
      color: #666;
    }

    .file-tree-close:hover {
      color: #333;
    }

    .file-tree-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }

    /* Utilities et animations */
    .hidden {
      display: none;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Indicateur de chargement */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 123, 255, 0.3);
      border-radius: 50%;
      border-top-color: #007bff;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Footer buttons */
    .footer-buttons {
      display: flex;
      justify-content: center;
      margin-top: 15px;
      gap: 10px;
    }

    .footer-btn {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      background: #6c757d;
      color: white;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .footer-btn:hover {
      background: #5a6268;
    }

    /* Dialog pour renommer */
    .rename-dialog {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .rename-dialog.show {
      display: flex;
    }

    .dialog-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
    }

    .dialog-title {
      margin-bottom: 15px;
      font-weight: bold;
    }

    .dialog-input {
      width: 100%;
      padding: 8px;
      margin-bottom: 15px;
      border: 1px solid #ced4da;
      border-radius: 4px;
    }

    .dialog-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .dialog-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .dialog-btn.cancel {
      background: #6c757d;
      color: white;
    }

    .dialog-btn.confirm {
      background: #28a745;
      color: white;
    }

    /* Animation pour attirer l'attention */
    @keyframes pulseHighlight {
      0% {
        box-shadow: 0 0 0 0 rgba(230, 119, 0, 0.5);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(230, 119, 0, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(230, 119, 0, 0);
      }
    }

    .highlight-pulse {
      animation: pulseHighlight 1.5s infinite;
    }

    /* Styles pour l'arborescence de fichiers interactive */
    .file-tree {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      line-height: 1.5;
    }

    .tree-toggle {
      cursor: pointer;
      user-select: none;
    }

    .folder-name {
      color: #0366d7;
      font-weight: normal;
    }

    .file-name {
      color: #333;
    }

    .folder-icon {
      color: #e8a100;
      margin-right: 5px;
    }

    .file-icon {
      color: #666;
      margin-right: 5px;
    }

    .tree-folder {
      margin: 2px 0;
    }

    .tree-file {
      margin: 2px 0;
    }

    .folder-contents {
      margin-left: 20px;
      border-left: 1px dotted #ddd;
      padding-left: 10px;
    }

    .toggle-icon {
      display: inline-block;
      width: 12px;
      text-align: center;
      transition: transform 0.2s;
    }

    .toggle-icon.collapsed {
      transform: rotate(-90deg);
    }

    /* Boutons de contrôle de l'arborescence */
    .tree-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div class="sidebar">
    <button id="new-chat" class="new-chat-btn">+ Nouvelle conversation</button>
    <div id="conversation-list" class="conversation-list">
      <!-- Les conversations seront ajoutées ici dynamiquement -->
    </div>
  </div>

  <div class="main-content">
    <div class="chat-header">Chat GPT-4.1 RAG</div>

    <div id="chat">
      <!-- Les messages seront ajoutés ici dynamiquement -->
    </div>

    <div class="input-container">
      <div class="model-selector-container">
        <div class="model-selector">
          <div class="model-selector-label">
            <div class="model-title">Modèle de langage :</div>
            <div class="model-info" id="model-recommendation">
              Utilisez GPT-4o (Vision) pour analyser des images
            </div>
          </div>
          <div class="model-options">
            <div class="model-option gpt-4-1 selected" data-model="gpt-4.1">
              GPT-4.1
            </div>
            <div class="model-option gpt-4o" data-model="gpt-4o">
              GPT-4o (Vision)
              <span class="model-option-badge" id="image-badge" style="display:none">Image détectée</span>
            </div>
          </div>
        </div>
      </div>

      <div class="input-wrapper">
        <textarea id="input"
          placeholder="Écris ton message... (Entrée = envoyer, Maj+Entrée ou Ctrl+Entrée = nouvelle ligne)"
          autocomplete="off"></textarea>

        <button id="send" disabled>
          <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="white" stroke-width="2" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg>
        </button>
      </div>

      <div id="image-preview" class="image-preview">
        <img id="preview-img" src="" alt="Aperçu de l'image">
        <button id="remove-image">&times;</button>
      </div>

      <div class="paste-info">Coller une image (Ctrl+V) pour l'intégrer à votre message</div>

      <div class="footer-buttons">
        <button id="clear" class="footer-btn">Effacer l'historique</button>
        <button id="show-tree" class="footer-btn">Afficher arbre</button>
      </div>
    </div>
  </div>

  <!-- Nouvelle structure pour l'arborescence de fichiers -->
  <div class="file-tree-overlay" id="file-tree-overlay"></div>
  <div class="file-tree-container" id="file-tree-container">
    <div class="file-tree-header">
      <div class="file-tree-title">Structure du projet</div>
      <div class="file-tree-actions">
        <button id="expand-all" class="footer-btn">Tout déployer</button>
        <button id="collapse-all" class="footer-btn">Tout replier</button>
        <button id="copy-tree" class="footer-btn">Copier l'arborescence</button>
        <button class="file-tree-close" id="close-tree">&times;</button>
      </div>
    </div>
    <div class="tree-controls">
      <button id="refresh-tree" class="footer-btn">Rafraîchir</button>
    </div>
    <div id="file-tree" class="file-tree"></div>
  </div>

  <!-- Dialog pour renommer une conversation -->
  <div id="rename-dialog" class="rename-dialog">
    <div class="dialog-content">
      <div class="dialog-title">Renommer la conversation</div>
      <input type="text" id="rename-input" class="dialog-input" placeholder="Nouveau nom">
      <div class="dialog-buttons">
        <button id="cancel-rename" class="dialog-btn cancel">Annuler</button>
        <button id="confirm-rename" class="dialog-btn confirm">Renommer</button>
      </div>
    </div>
  </div>

  <script>
    // Éléments DOM
    const chatEl = document.getElementById('chat');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const clearBtn = document.getElementById('clear');
    const showTreeBtn = document.getElementById('show-tree');
    const closeTreeBtn = document.getElementById('close-tree');
    const copyTreeBtn = document.getElementById('copy-tree');
    const fileTreeEl = document.getElementById('file-tree');
    const fileTreeContainer = document.getElementById('file-tree-container');
    const fileTreeOverlay = document.getElementById('file-tree-overlay');
    const imagePreviewEl = document.getElementById('image-preview');
    const previewImgEl = document.getElementById('preview-img');
    const removeImgBtn = document.getElementById('remove-image');
    const modelOptions = document.querySelectorAll('.model-option');
    const modelInfoEl = document.getElementById('model-recommendation');
    const newChatBtn = document.getElementById('new-chat');
    const conversationListEl = document.getElementById('conversation-list');
    const renameDialogEl = document.getElementById('rename-dialog');
    const renameInputEl = document.getElementById('rename-input');
    const cancelRenameBtn = document.getElementById('cancel-rename');
    const confirmRenameBtn = document.getElementById('confirm-rename');
    const imageBadgeEl = document.getElementById('image-badge');
    const expandAllBtn = document.getElementById('expand-all');
    const collapseAllBtn = document.getElementById('collapse-all');
    const refreshTreeBtn = document.getElementById('refresh-tree');

    // Variables globales
    let conversations = [];
    let currentConversationId = null;
    let treeVisible = false;
    let currentImageData = null;
    let currentImageType = null;
    let currentRenameId = null;
    let currentModel = 'gpt-4.1';
    let fileTreeData = null; // Stocker les données de l'arborescence
    let allFolders = []; // Stocker toutes les références aux dossiers pour expand/collapse all
    window.codeStorage = {}; // Storage for original code content

    /**
     * Charge et affiche l'arborescence de fichiers avec fonctionnalités interactives
     */
    async function loadAndDisplayFileTree() {
      try {
        // Afficher l'indicateur de chargement
        fileTreeEl.innerHTML = '<div style="text-align:center; padding:20px;"><div class="loading-spinner"></div> Chargement de l\'arborescence...</div>';
        fileTreeContainer.style.display = 'block';
        fileTreeOverlay.style.display = 'block';
        allFolders = []; // Réinitialiser la liste des dossiers

        // Charger les données de l'API
        const res = await fetch('/api/file-tree');
        if (!res.ok) {
          throw new Error(`Erreur lors du chargement: ${res.status}`);
        }

        fileTreeData = await res.json();

        // Générer l'arborescence interactive
        let treeHTML = '<div class="file-tree">';
        treeHTML += generateInteractiveTreeHTML(fileTreeData);
        treeHTML += '</div>';

        // Afficher le résultat
        fileTreeEl.innerHTML = treeHTML;

        // Ajouter les écouteurs d'événements pour les toggles des dossiers
        const toggles = document.querySelectorAll('.tree-toggle');
        toggles.forEach(toggle => {
          toggle.addEventListener('click', function () {
            const folderId = this.dataset.target;
            const folderEl = document.getElementById(folderId);
            const toggleIcon = this.querySelector('.toggle-icon');

            if (folderEl.style.display === 'none') {
              folderEl.style.display = 'block';
              toggleIcon.classList.remove('collapsed');
            } else {
              folderEl.style.display = 'none';
              toggleIcon.classList.add('collapsed');
            }
          });
        });

        // Ajuster la taille maximale
        const maxHeight = window.innerHeight * 0.8;
        fileTreeContainer.style.maxHeight = maxHeight + 'px';

      } catch (error) {
        console.error('Erreur:', error);
        fileTreeEl.innerHTML = `<div style="color:red; padding:20px;">
          Erreur lors du chargement: ${error.message}
        </div>`;
      }
    }

    /**
     * Génère le HTML pour l'arborescence interactive
     * @param {Object} node - Le nœud courant (fichier ou dossier)
     * @param {number} indent - Le niveau d'indentation
     * @returns {string} HTML généré
     */
    function generateInteractiveTreeHTML(node, indent = 0) {
      if (!node) return '';

      let html = '';
      const nodeId = 'node-' + Math.random().toString(36).substr(2, 9);

      // Si c'est un dossier
      if (node.type === 'dir') {
        // Créer l'élément de dossier avec toggle
        html += `<div class="tree-folder">
          <div class="tree-toggle" data-target="${nodeId}">
            <span class="toggle-icon">▾</span>
            <span class="folder-icon">📂</span>
            <span class="folder-name">${node.name || 'Sans nom'}</span>
          </div>
          <div id="${nodeId}" class="folder-contents">`;

        // Stocker la référence du dossier pour expand/collapse all
        allFolders.push(nodeId);

        // Si le dossier a des enfants, les afficher
        if (node.children && node.children.length > 0) {
          // Trier: dossiers d'abord, puis fichiers
          const sortedChildren = [...node.children].sort((a, b) => {
            if (a.type === 'dir' && b.type !== 'dir') return -1;
            if (a.type !== 'dir' && b.type === 'dir') return 1;
            return a.name.localeCompare(b.name);
          });

          sortedChildren.forEach(child => {
            html += generateInteractiveTreeHTML(child, indent + 1);
          });
        }

        html += `</div></div>`;
      }
      // Si c'est un fichier
      else {
        html += `<div class="tree-file">
          <span class="file-icon">📄</span>
          <span class="file-name">${node.name || 'Sans nom'}</span>
        </div>`;
      }

      return html;
    }

    /**
     * Déploie tous les dossiers de l'arborescence
     */
    function expandAllFolders() {
      allFolders.forEach(folderId => {
        const folderEl = document.getElementById(folderId);
        if (folderEl) {
          folderEl.style.display = 'block';

          // Mettre à jour l'icône toggle
          const toggleEl = document.querySelector(`[data-target="${folderId}"] .toggle-icon`);
          if (toggleEl) {
            toggleEl.classList.remove('collapsed');
          }
        }
      });
    }

    /**
     * Replie tous les dossiers de l'arborescence
     */
    function collapseAllFolders() {
      allFolders.forEach(folderId => {
        const folderEl = document.getElementById(folderId);
        if (folderEl) {
          folderEl.style.display = 'none';

          // Mettre à jour l'icône toggle
          const toggleEl = document.querySelector(`[data-target="${folderId}"] .toggle-icon`);
          if (toggleEl) {
            toggleEl.classList.add('collapsed');
          }
        }
      });
    }

    // Fonction simplifiée pour générer une représentation textuelle de l'arborescence
    function generateTextFileTree(tree) {
      if (!tree) return '';

      let result = '';

      function generateText(node, prefix = '', isLast = true) {
        if (!node) return;

        // Ajouter le nom du nœud avec le bon préfixe
        result += prefix;
        result += isLast ? '└── ' : '├── ';
        result += node.name + '\n';

        // Si c'est un dossier avec des enfants
        if (node.type === 'dir' && node.children && node.children.length > 0) {
          // Trier les enfants
          const sortedChildren = [...node.children].sort((a, b) => {
            if (a.type === 'dir' && b.type !== 'dir') return -1;
            if (a.type !== 'dir' && b.type === 'dir') return 1;
            return a.name.localeCompare(b.name);
          });

          // Générer le texte pour chaque enfant
          sortedChildren.forEach((child, idx) => {
            const isChildLast = idx === sortedChildren.length - 1;
            const newPrefix = prefix + (isLast ? '    ' : '│   ');
            generateText(child, newPrefix, isChildLast);
          });
        }
      }

      // Démarrer avec le nœud racine
      result += tree.name + '\n';

      if (tree.children && tree.children.length > 0) {
        const sortedChildren = [...tree.children].sort((a, b) => {
          if (a.type === 'dir' && b.type !== 'dir') return -1;
          if (a.type !== 'dir' && b.type === 'dir') return 1;
          return a.name.localeCompare(b.name);
        });

        sortedChildren.forEach((child, idx) => {
          generateText(child, '', idx === sortedChildren.length - 1);
        });
      }

      return result;
    }

    // Fonction de sanitisation pour tout contenu
    function sanitizeContent(content) {
      // Si c'est déjà une chaîne, la retourner telle quelle
      if (typeof content === 'string') {
        return content;
      }

      // Si c'est un objet ou autre chose, essayer de le convertir en JSON formaté
      try {
        if (content === null) return "null";
        if (content === undefined) return "undefined";

        // Si c'est un objet qui a une méthode toString personnalisée (comme Error), l'utiliser
        if (content instanceof Error) {
          return content.stack || content.toString();
        }

        // Pour les objets réguliers, utiliser JSON.stringify avec une indentation
        return "```json\n" + JSON.stringify(content, null, 2) + "\n```";
      } catch (err) {
        console.error("Erreur lors de la sanitisation du contenu:", err);
        // Fallback: conversion simple en chaîne
        return String(content);
      }
    }

    // Auto-resize de la zone de texte
    function autoResizeTextarea() {
      // Restaurer la hauteur minimale
      inputEl.style.height = 'auto';

      // Calculer la nouvelle hauteur en fonction du contenu
      // avec une valeur maximale pour éviter que la textarea prenne trop d'espace
      const newHeight = Math.min(Math.max(60, inputEl.scrollHeight), 300);
      inputEl.style.height = newHeight + 'px';
    }

    // Échapper les caractères HTML pour éviter l'injection de code
    function escapeHtml(text) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, function (m) {
        return map[m];
      });
    }

    // Préserver les espaces et indentations exactes dans le code
    function preserveCodeFormatting(code) {
      return code
        .replace(/ /g, '&nbsp;') // Remplacer les espaces par &nbsp;
        .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;') // Remplacer les tabulations
        .replace(/\n/g, '<br>'); // Remplacer les sauts de ligne
    }

    // Fonction de formatage Markdown personnalisée avec espacement compact
    function formatMarkdown(text) {
      if (!text) return '';

      // Échapper les caractères HTML pour éviter l'injection
      let formatted = escapeHtml(text);

      // Mettre en évidence les numéros des étapes (ex: "1. Texte")
      formatted = formatted.replace(/^(\d+)\.\s+(.*?)$/gm, function (match, number, content) {
        return `<div style="display:flex; margin:1px 0;">
          <div style="color:#0366d6; font-weight:bold; margin-right:5px;">${number}.</div>
          <div style="flex:1;">${content}</div>
        </div>`;
      });

      // Formater les blocs de code (```) avec préservation exacte du formatage
      formatted = formatted.replace(/```(\w*)\n([\s\S]*?)\n```/g, function (match, language, code) {
        language = language || 'text';
        const uniqueId = 'code-' + Math.random().toString(36).substr(2, 9);

        // Préserver exactement l'indentation et le formatage pour l'affichage
        const formattedCode = preserveCodeFormatting(code);

        // Stocker le code original dans le stockage global
        window.codeStorage[uniqueId] = code;

        return `
        <div class="code-block">
          <div class="language-indicator">${language}</div>
          <button onclick="copyCodeToClipboard('${uniqueId}')" class="copy-btn">Copier</button>
          <pre style="background: #f8f9fa; padding: 8px 12px; margin: 0; overflow-x: auto;">
            <code id="${uniqueId}" style="white-space: pre; tab-size: 4;">${formattedCode}</code>
          </pre>
        </div>
        `;
      });

      // Titres spéciaux avec emojis (## 🔵 Titre)
      formatted = formatted.replace(/^(#{1,6})\s+([\p{Emoji}])??\s*(.*?)$/gmu, function (match, hashes, emoji, content) {
        const level = hashes.length;
        const fontSize = 24 - (level * 2);
        const emojiHtml = emoji ? `<span style="margin-right:5px;">${emoji}</span>` : '';
        return `<h${level} style="font-size: ${fontSize}px; font-weight: bold; margin-top: 4px; margin-bottom: 2px; color: #000; line-height: 1.2;">
          ${emojiHtml}${content}</h${level}>`;
      });

      // Formater le texte en gras (**)
      formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 700; color: #000;">$1</strong>');

      // Formater le texte en italique (*)
      formatted = formatted.replace(/\*(.*?)\*/g, '<em style="font-style: italic; color: #333;">$1</em>');

      // Formater les séparateurs horizontaux (---)
      formatted = formatted.replace(/^---+$/gm, '<hr style="height: 1px; background-color: #ddd; border: none; margin: 4px 0;">');

      // Icônes de puces personnalisées avec couleurs
      formatted = formatted.replace(/^- (.*?)$/gm, '<div style="display:flex; margin:1px 0; align-items:flex-start;"><span style="display:inline-block; width:8px; height:8px; background-color:#0366d6; border-radius:50%; margin:6px 6px 0 0; flex-shrink:0;"></span><div style="flex:1; line-height:1.3;">$1</div></div>');

      // Mettre en évidence les chemins de fichiers
      formatted = formatted.replace(/`([^`]+)`/g, function (match, content) {
        // Si ça ressemble à un chemin de fichier ou code, le styliser différemment
        if (content.includes('/') || content.includes('.') || content.includes('()')) {
          return `<code style="background-color:#f1f1f1; padding:1px 4px; border-radius:3px; font-family:monospace; color:#e83e8c; font-size:0.9em;">${content}</code>`;
        }
        return `<code style="background-color:#f1f1f1; padding:1px 4px; border-radius:3px; font-family:monospace; font-size:0.9em;">${content}</code>`;
      });

      // Formater les paragraphes avec espacement réduit
      formatted = formatted.replace(/^(?!<[h|u|o|p|d|l|b|c|s|e|d])(.+)$/gm, '<p style="margin: 1px 0; line-height: 1.3;">$1</p>');

      // Éviter les doubles espaces entre paragraphes
      formatted = formatted.replace(/<\/p>\s*<p /g, '</p><p ');

      // Formater les émojis (pour 💡 et autres)
      formatted = formatted.replace(/([\u{1F300}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])/gu, '<span style="font-size: 1.2em; vertical-align: middle;">$1</span>');

      return formatted;
    }

    // Fonction pour copier le code avec une meilleure gestion des erreurs
    window.copyCodeToClipboard = function (elementId) {
      // Récupérer le code depuis le stockage global
      if (window.codeStorage && window.codeStorage[elementId]) {
        const originalCode = window.codeStorage[elementId];

        // Copier le code
        const textarea = document.createElement('textarea');
        textarea.value = originalCode;
        document.body.appendChild(textarea);
        textarea.select();

        try {
          const successful = document.execCommand('copy');
          // Feedback visuel
          const button = document.querySelector(`button[onclick="copyCodeToClipboard('${elementId}')"]`);
          if (button) {
            button.style.backgroundColor = successful ? '#28a745' : '#dc3545';
            button.textContent = successful ? 'Copié !' : 'Erreur';
            setTimeout(() => {
              button.style.backgroundColor = '#6c757d';
              button.textContent = 'Copier';
            }, 2000);
          }
        } catch (err) {
          console.error('Erreur lors de la copie:', err);
        } finally {
          document.body.removeChild(textarea);
        }
        return;
      }

      // Fallback si le code n'est pas dans le stockage global
      const codeElement = document.getElementById(elementId);
      if (!codeElement) {
        console.error('Élément code non trouvé:', elementId);
        return;
      }

      // Nettoyer directement le contenu du code
      let content = codeElement.innerHTML;
      content = content
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&nbsp;/g, ' ')
        .replace(/<\/?[^>]+(>|$)/g, '');

      // Copier le code nettoyé
      const textarea = document.createElement('textarea');
      textarea.value = content;
      document.body.appendChild(textarea);
      textarea.select();

      try {
        const successful = document.execCommand('copy');
        const button = document.querySelector(`button[onclick="copyCodeToClipboard('${elementId}')"]`);
        if (button) {
          button.style.backgroundColor = successful ? '#28a745' : '#dc3545';
          button.textContent = successful ? 'Copié !' : 'Erreur';
          setTimeout(() => {
            button.style.backgroundColor = '#6c757d';
            button.textContent = 'Copier';
          }, 2000);
        }
      } catch (err) {
        console.error('Erreur lors de la copie (fallback):', err);
      } finally {
        document.body.removeChild(textarea);
      }
    };

    // Ajouter un message au chat - fonction améliorée pour corriger le rendu Markdown
    function appendMessage(who, content) {
      const container = document.createElement('div');
      container.className = `message-container ${who}`;

      const div = document.createElement('div');
      div.className = `message ${who}`;

      // Si c'est un message de l'utilisateur, l'afficher tel quel
      if (who === 'user') {
        div.textContent = content;
      }
      // Si c'est un message du bot, appliquer notre formatage Markdown personnalisé
      else {
        // Convertir le contenu en chaîne si nécessaire
        const textContent = typeof content === 'string' ? content : sanitizeContent(content);

        // Appliquer notre propre formatage Markdown
        const formattedHtml = formatMarkdown(textContent);
        div.innerHTML = formattedHtml;
      }

      container.appendChild(div);
      chatEl.appendChild(container);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // Chargement des conversations depuis le localStorage
    function loadConversations() {
      const savedConversations = localStorage.getItem('chatConversations');
      if (savedConversations) {
        try {
          conversations = JSON.parse(savedConversations);
          updateConversationList();
        } catch (e) {
          console.error("Erreur lors du chargement des conversations:", e);
          conversations = [];
        }
      }

      // Si aucune conversation, en créer une nouvelle
      if (conversations.length === 0) {
        createNewConversation();
      } else {
        // Sélectionner la première conversation par défaut
        selectConversation(conversations[0].id);
      }
    }

    // Mise à jour de la liste des conversations
    function updateConversationList() {
      conversationListEl.innerHTML = '';

      conversations.forEach(conv => {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        if (conv.id === currentConversationId) {
          item.classList.add('active');
        }

        const title = document.createElement('div');
        title.className = 'conversation-title';
        title.textContent = conv.title || `Conversation ${conv.id.substring(0, 8)}`;

        const menuBtn = document.createElement('div');
        menuBtn.className = 'conversation-menu';
        menuBtn.innerHTML = '⋮';
        menuBtn.onclick = (e) => {
          e.stopPropagation();
          showConversationMenu(conv.id, e.target);
        };

        item.appendChild(title);
        item.appendChild(menuBtn);

        item.addEventListener('click', () => selectConversation(conv.id));
        conversationListEl.appendChild(item);
      });
    }

    // Afficher le menu contextuel d'une conversation
    function showConversationMenu(convId, target) {
      // Supprimer les menus existants
      document.querySelectorAll('.menu-dropdown').forEach(el => el.remove());

      const menu = document.createElement('div');
      menu.className = 'menu-dropdown show';

      const renameItem = document.createElement('div');
      renameItem.className = 'menu-item';
      renameItem.textContent = 'Renommer';
      renameItem.onclick = () => showRenameDialog(convId);

      const deleteItem = document.createElement('div');
      deleteItem.className = 'menu-item';
      deleteItem.textContent = 'Supprimer';
      deleteItem.onclick = () => deleteConversation(convId);

      menu.appendChild(renameItem);
      menu.appendChild(deleteItem);

      target.parentNode.appendChild(menu);

      // Fermer le menu quand on clique ailleurs
      document.addEventListener('click', function closeMenu(e) {
        if (!menu.contains(e.target) && e.target !== target) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }
      });
    }

    // Afficher la boîte de dialogue pour renommer une conversation
    function showRenameDialog(convId) {
      const conversation = conversations.find(c => c.id === convId);
      renameInputEl.value = conversation.title || `Conversation ${convId.substring(0, 8)}`;
      currentRenameId = convId;
      renameDialogEl.classList.add('show');
      renameInputEl.focus();
    }

    // Renommer une conversation
    function renameConversation(convId, newTitle) {
      const index = conversations.findIndex(c => c.id === convId);
      if (index !== -1) {
        conversations[index].title = newTitle;
        saveConversations();
        updateConversationList();
      }
    }

    // Supprimer une conversation
    function deleteConversation(convId) {
      if (confirm('Voulez-vous vraiment supprimer cette conversation ?')) {
        const index = conversations.findIndex(c => c.id === convId);
        if (index !== -1) {
          conversations.splice(index, 1);
          saveConversations();

          // Si c'était la conversation actuelle, sélectionner une autre
          if (convId === currentConversationId) {
            if (conversations.length > 0) {
              selectConversation(conversations[0].id);
            } else {
              createNewConversation();
            }
          } else {
            updateConversationList();
          }
        }
      }
    }

    // Sauvegarder les conversations dans le localStorage
    function saveConversations() {
      try {
        // Sanitiser chaque message avant de sauvegarder pour éviter les problèmes [object Object]
        const sanitizedConversations = conversations.map(conv => {
          // Créer une copie profonde de la conversation
          const sanitizedConv = { ...conv };

          // Sanitiser les messages
          if (Array.isArray(sanitizedConv.messages)) {
            sanitizedConv.messages = sanitizedConv.messages.map(msg => {
              // Si le contenu n'est pas une chaîne, le convertir
              if (typeof msg.content !== 'string') {
                return {
                  ...msg,
                  content: sanitizeContent(msg.content)
                };
              }
              return msg;
            });
          }

          return sanitizedConv;
        });

        localStorage.setItem('chatConversations', JSON.stringify(sanitizedConversations));
      } catch (error) {
        console.error("Erreur lors de la sauvegarde des conversations:", error);
        // Tentative de sauvegarde sans sanitisation en cas d'erreur
        try {
          localStorage.setItem('chatConversations', JSON.stringify(conversations));
        } catch (fallbackError) {
          console.error("Échec total de la sauvegarde:", fallbackError);
        }
      }
    }

    // Créer une nouvelle conversation
    function createNewConversation() {
      const newId = `conv_${Date.now()}`;
      const newConversation = {
        id: newId,
        title: '',
        messages: [],
        images: []
      };

      conversations.unshift(newConversation);
      saveConversations();
      selectConversation(newId);
    }

    // Sélectionner une conversation
    function selectConversation(convId) {
      currentConversationId = convId;
      updateConversationList();
      loadCurrentConversation();
    }

    // Charger la conversation actuelle
    function loadCurrentConversation() {
      chatEl.innerHTML = '';

      const conversation = conversations.find(c => c.id === currentConversationId);
      if (!conversation) return;

      // Afficher les messages
      conversation.messages.forEach(msg => {
        if (msg.role === 'user') {
          appendMessage('user', msg.content);
        } else if (msg.role === 'assistant') {
          appendMessage('bot', msg.content);
        }
      });

      // Afficher les images
      conversation.images && conversation.images.forEach(img => {
        appendImage('user', img.data);
      });
    }

    // Changer de modèle
    function selectModel(modelValue) {
      currentModel = modelValue;

      // Mise à jour de l'apparence
      modelOptions.forEach(option => {
        if (option.dataset.model === modelValue) {
          option.classList.add('selected');
        } else {
          option.classList.remove('selected');
        }
      });

      // Mise à jour du message de recommandation
      if (modelValue === 'gpt-4o') {
        modelInfoEl.textContent = 'Mode vision activé - Peut analyser des images';
      } else {
        modelInfoEl.textContent = 'Utilisez GPT-4o (Vision) pour analyser des images';
      }
    }

    // Auto-détecter le modèle en fonction de la présence d'image
    function autoDetectModel() {
      if (currentImageData) {
        selectModel('gpt-4o');
        imageBadgeEl.style.display = 'block';

        // Ajouter un effet pulsant pour attirer l'attention
        const gpt4oOption = document.querySelector('.model-option.gpt-4o');
        gpt4oOption.classList.add('highlight-pulse');

        // Enlever l'effet après 3 secondes
        setTimeout(() => {
          gpt4oOption.classList.remove('highlight-pulse');
        }, 3000);
      } else {
        imageBadgeEl.style.display = 'none';
      }
    }

    // Ajouter une image au chat
    function appendImage(who, imageData) {
      const container = document.createElement('div');
      container.className = `message-container ${who}`;

      const div = document.createElement('div');
      div.className = `message ${who}`;

      const img = document.createElement('img');
      img.src = imageData;
      img.className = 'chat-image';
      img.alt = 'Image partagée';

      div.appendChild(img);
      container.appendChild(div);
      chatEl.appendChild(container);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // Indication de chargement
    let typingEl = null;
    function showTyping() {
      typingEl = document.createElement('div');
      typingEl.className = 'message-container';

      const message = document.createElement('div');
      message.className = 'message bot typing';
      message.textContent = '...';

      typingEl.appendChild(message);
      chatEl.appendChild(typingEl);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    function hideTyping() {
      if (typingEl) {
        chatEl.removeChild(typingEl);
        typingEl = null;
      }
    }

    // Fonction uploadImage améliorée
    async function uploadImage(imageData, imageType) {
      try {
        console.log("Téléchargement de l'image vers le serveur...");

        const res = await fetch('/api/images/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageData,
            chatId: currentConversationId,
            mimeType: imageType
          })
        });

        if (!res.ok) {
          throw new Error(`Erreur lors du téléchargement de l'image: ${res.status}`);
        }

        return await res.json();
      } catch (error) {
        console.error('Erreur uploadImage:', error);
        // Retourner un résultat factice en cas d'erreur pour éviter de bloquer le flux
        return {
          success: false,
          imageId: "local_" + Date.now(),
          error: error.message
        };
      }
    }

    // Fonction send unifiée et corrigée
    async function send() {
      const message = inputEl.value.trim();

      // Si ni message ni image, ne rien faire
      if (!message && !currentImageData) return;

      // Créer une COPIE de l'image actuelle avant tout traitement
      const imageDataForAPI = currentImageData;

      // Ajouter le message de l'utilisateur au chat
      if (message) {
        appendMessage('user', message);
      }

      // Ajouter l'image au chat si présente
      if (currentImageData) {
        appendImage('user', currentImageData);

        // Sauvegarder l'image dans la conversation
        const currentConversation = conversations.find(c => c.id === currentConversationId);
        if (currentConversation) {
          if (!currentConversation.images) currentConversation.images = [];
          currentConversation.images.push({
            data: currentImageData,
            type: currentImageType,
            timestamp: Date.now()
          });
          saveConversations();
        }
      }

      // Réinitialiser l'input texte
      inputEl.value = '';
      inputEl.style.height = '60px';

      // Ne pas envoyer au serveur si uniquement une image sans message
      if (!message) {
        // Nettoyer l'interface pour l'image
        imagePreviewEl.style.display = 'none';
        currentImageData = null;
        currentImageType = null;
        imageBadgeEl.style.display = 'none';
        return;
      }

      // Mettre à jour la conversation actuelle
      const currentConversation = conversations.find(c => c.id === currentConversationId);
      if (currentConversation) {
        currentConversation.messages.push({ role: 'user', content: message });
        saveConversations();
      }

      // Envoyer au serveur
      showTyping();
      try {
        // IMPORTANT: Utiliser la COPIE de l'image, pas la référence qui sera nettoyée
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message,
            history: currentConversation ? currentConversation.messages : [],
            imageData: imageDataForAPI,
            modelChoice: currentModel
          })
        });

        // SEULEMENT APRÈS que la requête est envoyée, on nettoie l'interface d'image
        imagePreviewEl.style.display = 'none';
        currentImageData = null;
        currentImageType = null;
        imageBadgeEl.style.display = 'none';

        if (!res.ok) {
          throw new Error(`Erreur serveur: ${res.status}`);
        }

        const responseData = await res.json();
        hideTyping();

        console.log("🔍 Réponse reçue du serveur:", responseData);

        // Traitement de la réponse
        if (responseData && typeof responseData === 'object' && 'reply' in responseData) {
          appendMessage('bot', responseData.reply);

          if (currentConversation) {
            currentConversation.messages.push({ role: 'assistant', content: responseData.reply });
          }
        } else {
          const sanitizedContent = typeof responseData === 'string'
            ? responseData
            : sanitizeContent(responseData);

          appendMessage('bot', sanitizedContent);

          if (currentConversation) {
            currentConversation.messages.push({
              role: 'assistant',
              content: sanitizedContent
            });
          }
        }

        // Si la conversation n'a pas de titre, utiliser le premier message
        if (currentConversation && !currentConversation.title && currentConversation.messages.length === 2) {
          const firstMsg = message.substring(0, 30);
          currentConversation.title = firstMsg + (message.length > 30 ? '...' : '');
        }

        saveConversations();
        updateConversationList();
      } catch (err) {
        hideTyping();
        appendMessage('bot', `Erreur de connexion au serveur: ${err.message}`);

        // Nettoyer l'image en cas d'erreur aussi
        if (currentImageData) {
          imagePreviewEl.style.display = 'none';
          currentImageData = null;
          currentImageType = null;
          imageBadgeEl.style.display = 'none';
        }
      }
    }

    // Activer/désactiver le bouton d'envoi
    function toggleSendButton() {
      const hasText = inputEl.value.trim().length > 0;
      const hasImage = currentImageData !== null;
      sendBtn.disabled = !hasText && !hasImage;
    }

    // Copier l'arborescence au format texte
    function copyFileTree() {
      if (!fileTreeData) return;

      // Générer la représentation textuelle
      const treeText = generateTextFileTree(fileTreeData);

      // Copier dans le presse-papiers
      const textarea = document.createElement('textarea');
      textarea.value = treeText;
      document.body.appendChild(textarea);
      textarea.select();

      try {
        const successful = document.execCommand('copy');

        // Feedback visuel
        copyTreeBtn.style.backgroundColor = successful ? '#28a745' : '#dc3545';
        copyTreeBtn.textContent = successful ? 'Copié !' : 'Erreur';

        setTimeout(() => {
          copyTreeBtn.style.backgroundColor = '#6c757d';
          copyTreeBtn.textContent = 'Copier l\'arborescence';
        }, 2000);
      } catch (err) {
        console.error('Erreur lors de la copie de l\'arborescence:', err);
      } finally {
        document.body.removeChild(textarea);
      }
    }

    // Événements

    // Sélection du modèle
    modelOptions.forEach(option => {
      option.addEventListener('click', () => {
        selectModel(option.dataset.model);
      });
    });

    // Auto-resize de la zone de texte
    inputEl.addEventListener('input', function () {
      autoResizeTextarea();
      toggleSendButton();
    });

    // Entrée pour envoyer, Maj+Entrée OU Ctrl+Entrée pour nouvelle ligne
    inputEl.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        if (e.ctrlKey || e.shiftKey) {
          // Ajouter une nouvelle ligne
          const start = inputEl.selectionStart;
          const end = inputEl.selectionEnd;
          const value = inputEl.value;
          inputEl.value = value.substring(0, start) + '\n' + value.substring(end);
          inputEl.selectionStart = inputEl.selectionEnd = start + 1;

          // Auto-resize
          setTimeout(autoResizeTextarea, 0);
        } else {
          // Empêcher le retour à la ligne par défaut
          e.preventDefault();
          if (!sendBtn.disabled) {
            send();
          }
        }
      }
    });

    // Gestionnaire spécial de presse-papier
    document.addEventListener('paste', function (e) {
      // Si l'élément actif n'est pas notre textarea d'entrée, ne rien faire
      if (document.activeElement !== inputEl) return;

      const items = (e.clipboardData || e.originalEvent.clipboardData).items;

      // Chercher d'abord s'il y a une image
      let hasImage = false;
      for (const item of items) {
        if (item.type.startsWith('image')) {
          hasImage = true;
          const blob = item.getAsFile();
          const reader = new FileReader();

          reader.onload = function (event) {
            // Récupérer les données de l'image
            currentImageData = event.target.result;
            currentImageType = item.type;

            // Afficher l'aperçu de l'image
            previewImgEl.src = currentImageData;
            imagePreviewEl.style.display = 'block';

            // Auto-détecter le modèle
            autoDetectModel();

            // Activer le bouton d'envoi
            toggleSendButton();
          };

          reader.readAsDataURL(blob);
          break;
        }
      }

      // Si ce n'est pas une image, traiter comme du texte brut
      if (!hasImage) {
        // Obtenir le contenu du presse-papier comme texte brut
        const clipboardData = e.clipboardData || window.clipboardData;
        const pastedText = clipboardData.getData('text/plain');

        // Si du texte a été trouvé, l'insérer à la position du curseur
        if (pastedText) {
          // Obtenir les positions de sélection
          const startPos = inputEl.selectionStart;
          const endPos = inputEl.selectionEnd;

          // Insérer le texte à la position du curseur
          const currentValue = inputEl.value;
          inputEl.value = currentValue.substring(0, startPos) + pastedText + currentValue.substring(endPos);

          // Repositionner le curseur après le texte collé
          inputEl.selectionStart = inputEl.selectionEnd = startPos + pastedText.length;

          // Déclencher l'auto-resize
          setTimeout(autoResizeTextarea, 0);
          toggleSendButton();

          // Empêcher le comportement par défaut qui pourrait causer des problèmes avec les objets
          e.preventDefault();
        }
      }
    }, { passive: false });

    // Supprimer l'image en cours
    removeImgBtn.addEventListener('click', () => {
      imagePreviewEl.style.display = 'none';
      currentImageData = null;
      currentImageType = null;
      imageBadgeEl.style.display = 'none';
      toggleSendButton();
    });

    // Bouton d'envoi
    sendBtn.addEventListener('click', send);

    // Nouvelle conversation
    newChatBtn.addEventListener('click', createNewConversation);

    // Effacer l'historique
    clearBtn.addEventListener('click', () => {
      if (confirm('Voulez-vous effacer l\'historique de cette conversation?')) {
        const currentConversation = conversations.find(c => c.id === currentConversationId);
        if (currentConversation) {
          currentConversation.messages = [];
          currentConversation.images = [];
          saveConversations();
          loadCurrentConversation();
        }
      }
    });

    // Afficher l'arborescence
    showTreeBtn.addEventListener('click', loadAndDisplayFileTree);

    // Fermer l'arborescence
    closeTreeBtn.addEventListener('click', () => {
      fileTreeContainer.style.display = 'none';
      fileTreeOverlay.style.display = 'none';
    });

    // Fermer l'arborescence en cliquant sur l'overlay
    fileTreeOverlay.addEventListener('click', () => {
      fileTreeContainer.style.display = 'none';
      fileTreeOverlay.style.display = 'none';
    });

    // Copier l'arborescence
    copyTreeBtn.addEventListener('click', copyFileTree);

    // Tout déployer
    expandAllBtn.addEventListener('click', expandAllFolders);

    // Tout replier
    collapseAllBtn.addEventListener('click', collapseAllFolders);

    // Rafraîchir l'arborescence
    refreshTreeBtn.addEventListener('click', loadAndDisplayFileTree);

    // Boutons de la boîte de dialogue de renommage
    cancelRenameBtn.addEventListener('click', () => {
      renameDialogEl.classList.remove('show');
      currentRenameId = null;
    });

    confirmRenameBtn.addEventListener('click', () => {
      if (currentRenameId) {
        const newTitle = renameInputEl.value.trim();
        if (newTitle) {
          renameConversation(currentRenameId, newTitle);
        }
      }
      renameDialogEl.classList.remove('show');
      currentRenameId = null;
    });

    // Fermer la boîte de dialogue en cliquant en dehors
    renameDialogEl.addEventListener('click', e => {
      if (e.target === renameDialogEl) {
        renameDialogEl.classList.remove('show');
        currentRenameId = null;
      }
    });

    // Définir un gestionnaire global d'erreurs pour éviter les [object Object]
    window.addEventListener('error', function (e) {
      console.error('Une erreur est survenue:', e.error);
      // Éviter d'afficher l'erreur à l'utilisateur
      e.preventDefault();
    });

    // Initialisation
    loadConversations();

    // S'assurer que le champ d'entrée est focusé automatiquement
    inputEl.focus();

    // Désactiver le bouton d'envoi par défaut (jusqu'à ce qu'il y ait du texte ou une image)
    toggleSendButton();
  </script>
</body>

</html>
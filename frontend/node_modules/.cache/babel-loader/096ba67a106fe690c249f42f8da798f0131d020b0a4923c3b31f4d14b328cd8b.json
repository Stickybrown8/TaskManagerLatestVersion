{"ast":null,"code":"import { configureStore, createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService, clientsService, tasksService } from './api';\n\n// Thunk pour la connexion\nexport const login = createAsyncThunk('auth/login', async ({\n  email,\n  password\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const user = await authService.login(email, password);\n    return user;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    return rejectWithValue(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Erreur de connexion');\n  }\n});\n\n// Thunk pour vérifier l'authentification\nexport const checkAuth = createAsyncThunk('auth/check', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const user = await authService.checkAuth();\n    return user;\n  } catch (error) {\n    return rejectWithValue('Session expirée');\n  }\n});\n\n// Slice d'authentification\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState: {\n    isAuthenticated: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  reducers: {\n    logout: state => {\n      authService.logout();\n      state.isAuthenticated = false;\n      state.user = null;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(login.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(login.fulfilled, (state, action) => {\n      state.loading = false;\n      state.isAuthenticated = true;\n      state.user = action.payload;\n    }).addCase(login.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    }).addCase(checkAuth.fulfilled, (state, action) => {\n      if (action.payload) {\n        state.isAuthenticated = true;\n        state.user = action.payload;\n      }\n    });\n  }\n});\n\n// Thunk pour récupérer les clients\nexport const fetchClients = createAsyncThunk('clients/fetchClients', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const clients = await clientsService.getClients();\n    return clients;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    return rejectWithValue(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Erreur lors de la récupération des clients');\n  }\n});\n\n// Slice des clients\nconst clientsSlice = createSlice({\n  name: 'clients',\n  initialState: {\n    clients: [],\n    loading: false,\n    error: null\n  },\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchClients.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchClients.fulfilled, (state, action) => {\n      state.loading = false;\n      state.clients = action.payload;\n    }).addCase(fetchClients.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Thunk pour récupérer les tâches\nexport const fetchTasks = createAsyncThunk('tasks/fetchTasks', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const tasks = await tasksService.getTasks();\n    return tasks;\n  } catch (error) {\n    var _error$response3, _error$response3$data;\n    return rejectWithValue(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Erreur lors de la récupération des tâches');\n  }\n});\n\n// Slice des tâches\nconst tasksSlice = createSlice({\n  name: 'tasks',\n  initialState: {\n    tasks: [],\n    loading: false,\n    error: null\n  },\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchTasks.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchTasks.fulfilled, (state, action) => {\n      state.loading = false;\n      state.tasks = action.payload;\n    }).addCase(fetchTasks.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Export des actions\nexport const {\n  logout\n} = authSlice.actions;\n\n// Store Redux avec les reducers\nexport const store = configureStore({\n  reducer: {\n    auth: authSlice.reducer,\n    clients: clientsSlice.reducer,\n    tasks: tasksSlice.reducer\n  }\n});","map":{"version":3,"names":["configureStore","createSlice","createAsyncThunk","authService","clientsService","tasksService","login","email","password","rejectWithValue","user","error","_error$response","_error$response$data","response","data","message","checkAuth","_","authSlice","name","initialState","isAuthenticated","loading","reducers","logout","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","fetchClients","clients","getClients","_error$response2","_error$response2$data","clientsSlice","fetchTasks","tasks","getTasks","_error$response3","_error$response3$data","tasksSlice","actions","store","reducer","auth"],"sources":["C:/Users/Steve/Documents/Dernier projet task manager/task-manager-complete-main (1)/task-manager-complete-main/frontend/src/store.js"],"sourcesContent":["import { configureStore, createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService, clientsService, tasksService } from './api';\n\n// Thunk pour la connexion\nexport const login = createAsyncThunk(\n  'auth/login',\n  async ({ email, password }, { rejectWithValue }) => {\n    try {\n      const user = await authService.login(email, password);\n      return user;\n    } catch (error) {\n      return rejectWithValue(error.response?.data?.message || 'Erreur de connexion');\n    }\n  }\n);\n\n// Thunk pour vérifier l'authentification\nexport const checkAuth = createAsyncThunk(\n  'auth/check',\n  async (_, { rejectWithValue }) => {\n    try {\n      const user = await authService.checkAuth();\n      return user;\n    } catch (error) {\n      return rejectWithValue('Session expirée');\n    }\n  }\n);\n\n// Slice d'authentification\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState: {\n    isAuthenticated: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  reducers: {\n    logout: (state) => {\n      authService.logout();\n      state.isAuthenticated = false;\n      state.user = null;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(login.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(login.fulfilled, (state, action) => {\n        state.loading = false;\n        state.isAuthenticated = true;\n        state.user = action.payload;\n      })\n      .addCase(login.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      })\n      .addCase(checkAuth.fulfilled, (state, action) => {\n        if (action.payload) {\n          state.isAuthenticated = true;\n          state.user = action.payload;\n        }\n      });\n  }\n});\n\n// Thunk pour récupérer les clients\nexport const fetchClients = createAsyncThunk(\n  'clients/fetchClients',\n  async (_, { rejectWithValue }) => {\n    try {\n      const clients = await clientsService.getClients();\n      return clients;\n    } catch (error) {\n      return rejectWithValue(error.response?.data?.message || 'Erreur lors de la récupération des clients');\n    }\n  }\n);\n\n// Slice des clients\nconst clientsSlice = createSlice({\n  name: 'clients',\n  initialState: {\n    clients: [],\n    loading: false,\n    error: null\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchClients.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchClients.fulfilled, (state, action) => {\n        state.loading = false;\n        state.clients = action.payload;\n      })\n      .addCase(fetchClients.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      });\n  }\n});\n\n// Thunk pour récupérer les tâches\nexport const fetchTasks = createAsyncThunk(\n  'tasks/fetchTasks',\n  async (_, { rejectWithValue }) => {\n    try {\n      const tasks = await tasksService.getTasks();\n      return tasks;\n    } catch (error) {\n      return rejectWithValue(error.response?.data?.message || 'Erreur lors de la récupération des tâches');\n    }\n  }\n);\n\n// Slice des tâches\nconst tasksSlice = createSlice({\n  name: 'tasks',\n  initialState: {\n    tasks: [],\n    loading: false,\n    error: null\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchTasks.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchTasks.fulfilled, (state, action) => {\n        state.loading = false;\n        state.tasks = action.payload;\n      })\n      .addCase(fetchTasks.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      });\n  }\n});\n\n// Export des actions\nexport const { logout } = authSlice.actions;\n\n// Store Redux avec les reducers\nexport const store = configureStore({\n  reducer: {\n    auth: authSlice.reducer,\n    clients: clientsSlice.reducer,\n    tasks: tasksSlice.reducer\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
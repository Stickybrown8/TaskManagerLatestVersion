{"ast":null,"code":"import { createSlice, createAction } from '@reduxjs/toolkit';\n\n// Définition des interfaces pour les types\n\n// Définition du type AppThunk si non exporté depuis '..'\n\n// Fonction utilitaire pour gérer les dates potentiellement undefined\nconst safeDate = date => {\n  if (!date) return new Date();\n  try {\n    return new Date(date instanceof Date ? date : new Date(date));\n  } catch (error) {\n    return new Date();\n  }\n};\n\n// Simuler les fonctions d'API si elles ne sont pas disponibles\n// Ces fonctions devraient être remplacées par les véritables implémentations\nconst fetchClientTimersFromAPI = async () => {\n  // Simulation - à remplacer par l'appel API réel\n  return {};\n};\nconst fetchTaskTimersFromAPI = async () => {\n  // Simulation - à remplacer par l'appel API réel\n  return {};\n};\n\n// État initial\nconst initialState = {\n  clientTimers: {},\n  taskTimers: {},\n  currentTimer: null,\n  runningTimer: null,\n  showTimerPopup: false,\n  // Assurez-vous que cette ligne existe\n  timerPopupSize: 'medium',\n  timerPopupPosition: 'bottom-right',\n  loading: false,\n  error: null\n};\n\n// Actions pour les opérations asynchrones\nconst fetchClientTimersPending = createAction('timer/fetchClientTimers/pending');\nconst fetchClientTimersFulfilled = createAction('timer/fetchClientTimers/fulfilled');\nconst fetchClientTimersRejected = createAction('timer/fetchClientTimers/rejected');\nconst fetchTaskTimersPending = createAction('timer/fetchTaskTimers/pending');\nconst fetchTaskTimersFulfilled = createAction('timer/fetchTaskTimers/fulfilled');\nconst fetchTaskTimersRejected = createAction('timer/fetchTaskTimers/rejected');\nconst fetchRunningTimerPending = createAction('timer/fetchRunningTimer/pending');\nconst fetchRunningTimerFulfilled = createAction('timer/fetchRunningTimer/fulfilled');\nconst fetchRunningTimerRejected = createAction('timer/fetchRunningTimer/rejected');\n\n// Création du slice\nconst timerSlice = createSlice({\n  name: 'timer',\n  initialState,\n  reducers: {\n    // Définir le timer actuel\n    setCurrentTimer: (state, action) => {\n      state.currentTimer = action.payload;\n    },\n    // Définir le timer en cours d'exécution\n    setRunningTimer: (state, action) => {\n      state.runningTimer = action.payload;\n    },\n    // Mettre à jour la durée d'un timer en cours\n    updateRunningTimerDuration: state => {\n      if (state.currentTimer && state.currentTimer.isRunning && state.currentTimer.startTime) {\n        // Utiliser safeDate pour éviter l'erreur TypeScript\n        const startTime = safeDate(state.currentTimer.startTime);\n        const currentTime = new Date();\n        const elapsedTime = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);\n        const type = state.currentTimer.clientId ? 'client' : 'task';\n        const timerId = state.currentTimer.clientId || state.currentTimer.taskId;\n        if (timerId) {\n          const timers = type === 'client' ? state.clientTimers : state.taskTimers;\n          if (timers[timerId]) {\n            timers[timerId].duration = elapsedTime;\n            state.currentTimer.duration = elapsedTime;\n\n            // Mettre à jour également runningTimer si c'est le même timer\n            if (state.runningTimer && (type === 'client' && state.runningTimer.clientId === timerId || type === 'task' && state.runningTimer.taskId === timerId)) {\n              state.runningTimer.duration = elapsedTime;\n            }\n          }\n        }\n      }\n    },\n    // Afficher/masquer la popup de timer\n    toggleTimerPopup: (state, action) => {\n      state.showTimerPopup = action.payload; // Assurez-vous que cette ligne existe\n    },\n    // Définir la taille de la popup de timer\n    setTimerPopupSize: (state, action) => {\n      state.timerPopupSize = action.payload;\n    },\n    // Définir la position de la popup de timer\n    setTimerPopupPosition: (state, action) => {\n      state.timerPopupPosition = action.payload;\n    },\n    // Mettre à jour le statut d'un timer\n    updateTimerStatus: (state, action) => {\n      const {\n        timerId,\n        type,\n        isRunning\n      } = action.payload;\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\n      if (timers[timerId]) {\n        timers[timerId].isRunning = isRunning;\n        if (isRunning) {\n          timers[timerId].startTime = new Date();\n\n          // Si le timer est démarré, le définir comme runningTimer\n          state.runningTimer = timers[timerId];\n        } else if (state.runningTimer && (type === 'client' && state.runningTimer.clientId === timerId || type === 'task' && state.runningTimer.taskId === timerId)) {\n          // Si le timer est arrêté et qu'il s'agit du runningTimer, réinitialiser runningTimer\n          state.runningTimer = null;\n        }\n      }\n    },\n    // Mettre à jour le timer actuel s'il correspond\n    updateCurrentTimerIfMatches: (state, action) => {\n      const {\n        timerId,\n        type,\n        isRunning\n      } = action.payload;\n      if (state.currentTimer) {\n        const currentTimerId = type === 'client' ? state.currentTimer.clientId : state.currentTimer.taskId;\n        if (currentTimerId === timerId) {\n          state.currentTimer.isRunning = isRunning;\n          if (isRunning) {\n            state.currentTimer.startTime = new Date();\n          }\n        }\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Gestion des timers clients\n    .addCase(fetchClientTimersPending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchClientTimersFulfilled, (state, action) => {\n      state.loading = false;\n      state.clientTimers = action.payload;\n    }).addCase(fetchClientTimersRejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Gestion des timers de tâches\n    .addCase(fetchTaskTimersPending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchTaskTimersFulfilled, (state, action) => {\n      state.loading = false;\n      state.taskTimers = action.payload;\n    }).addCase(fetchTaskTimersRejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Gestion du timer en cours\n    .addCase(fetchRunningTimerPending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchRunningTimerFulfilled, state => {\n      state.loading = false;\n    }).addCase(fetchRunningTimerRejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Export des actions\nexport const {\n  setCurrentTimer,\n  setRunningTimer,\n  updateRunningTimerDuration,\n  toggleTimerPopup,\n  setTimerPopupSize,\n  setTimerPopupPosition,\n  updateTimerStatus,\n  updateCurrentTimerIfMatches\n} = timerSlice.actions;\n\n// Thunks pour les opérations asynchrones\nexport const fetchClientTimers = () => async dispatch => {\n  try {\n    dispatch(fetchClientTimersPending());\n    const clientTimers = await fetchClientTimersFromAPI();\n    dispatch(fetchClientTimersFulfilled(clientTimers));\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\n    dispatch(fetchClientTimersRejected(errorMessage));\n  }\n};\nexport const fetchTaskTimers = () => async dispatch => {\n  try {\n    dispatch(fetchTaskTimersPending());\n    const taskTimers = await fetchTaskTimersFromAPI();\n    dispatch(fetchTaskTimersFulfilled(taskTimers));\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\n    dispatch(fetchTaskTimersRejected(errorMessage));\n  }\n};\nexport const fetchRunningTimer = () => async dispatch => {\n  try {\n    dispatch(fetchRunningTimerPending());\n\n    // Vérifier d'abord les timers clients\n    const clientTimers = await fetchClientTimersFromAPI();\n    const runningClientTimer = Object.values(clientTimers).find(timer => timer.isRunning);\n    if (runningClientTimer) {\n      // Si un timer client est en cours d'exécution, le définir comme timer actuel et comme runningTimer\n      dispatch(setCurrentTimer(runningClientTimer));\n      dispatch(setRunningTimer(runningClientTimer));\n    } else {\n      // Sinon, vérifier les timers de tâches\n      const taskTimers = await fetchTaskTimersFromAPI();\n      const runningTaskTimer = Object.values(taskTimers).find(timer => timer.isRunning);\n      if (runningTaskTimer) {\n        dispatch(setCurrentTimer(runningTaskTimer));\n        dispatch(setRunningTimer(runningTaskTimer));\n      }\n    }\n    dispatch(fetchRunningTimerFulfilled());\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\n    dispatch(fetchRunningTimerRejected(errorMessage));\n  }\n};\n\n// Fonction hideTimerPopup ajoutée (utilise toggleTimerPopup avec false)\nexport const hideTimerPopup = () => dispatch => {\n  dispatch(toggleTimerPopup(false));\n};\n\n// Fonction pauseTimer ajoutée\nexport const pauseTimer = (timerId, type) => async dispatch => {\n  try {\n    // Mettre à jour l'état local\n    dispatch(updateTimerStatus({\n      timerId,\n      type,\n      isRunning: false\n    }));\n\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\n    dispatch(updateCurrentTimerIfMatches({\n      timerId,\n      type,\n      isRunning: false\n    }));\n\n    // Appel API pour mettre à jour le timer sur le serveur\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n    // await timerService.pauseTimer(timerId, type);\n  } catch (error) {\n    console.error('Erreur lors de la mise en pause du timer:', error);\n  }\n};\n\n// Fonction startTimer ajoutée\nexport const startTimer = (timerId, type) => async dispatch => {\n  try {\n    // Mettre à jour l'état local\n    dispatch(updateTimerStatus({\n      timerId,\n      type,\n      isRunning: true\n    }));\n\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\n    dispatch(updateCurrentTimerIfMatches({\n      timerId,\n      type,\n      isRunning: true\n    }));\n\n    // Appel API pour mettre à jour le timer sur le serveur\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n    // await timerService.startTimer(timerId, type);\n  } catch (error) {\n    console.error('Erreur lors du démarrage du timer:', error);\n  }\n};\n\n// Fonction resumeTimer ajoutée (identique à startTimer mais avec un nom différent)\nexport const resumeTimer = (timerId, type) => async dispatch => {\n  try {\n    // Mettre à jour l'état local\n    dispatch(updateTimerStatus({\n      timerId,\n      type,\n      isRunning: true\n    }));\n\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\n    dispatch(updateCurrentTimerIfMatches({\n      timerId,\n      type,\n      isRunning: true\n    }));\n\n    // Appel API pour mettre à jour le timer sur le serveur\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n    // await timerService.resumeTimer(timerId, type);\n  } catch (error) {\n    console.error('Erreur lors de la reprise du timer:', error);\n  }\n};\n\n// Fonction stopTimer ajoutée (similaire à pauseTimer mais peut réinitialiser le timer)\nexport const stopTimer = (timerId, type, reset = false) => async dispatch => {\n  try {\n    // Mettre à jour l'état local\n    dispatch(updateTimerStatus({\n      timerId,\n      type,\n      isRunning: false\n    }));\n\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\n    dispatch(updateCurrentTimerIfMatches({\n      timerId,\n      type,\n      isRunning: false\n    }));\n\n    // Si reset est true, réinitialiser la durée du timer\n    if (reset) {\n      // Cette partie nécessiterait un nouveau reducer pour réinitialiser la durée\n      // Pour l'instant, nous nous contentons d'arrêter le timer\n    }\n\n    // Appel API pour mettre à jour le timer sur le serveur\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n    // await timerService.stopTimer(timerId, type, reset);\n  } catch (error) {\n    console.error('Erreur lors de l\\'arrêt du timer:', error);\n  }\n};\nexport default timerSlice.reducer;","map":{"version":3,"names":["createSlice","createAction","safeDate","date","Date","error","fetchClientTimersFromAPI","fetchTaskTimersFromAPI","initialState","clientTimers","taskTimers","currentTimer","runningTimer","showTimerPopup","timerPopupSize","timerPopupPosition","loading","fetchClientTimersPending","fetchClientTimersFulfilled","fetchClientTimersRejected","fetchTaskTimersPending","fetchTaskTimersFulfilled","fetchTaskTimersRejected","fetchRunningTimerPending","fetchRunningTimerFulfilled","fetchRunningTimerRejected","timerSlice","name","reducers","setCurrentTimer","state","action","payload","setRunningTimer","updateRunningTimerDuration","isRunning","startTime","currentTime","elapsedTime","Math","floor","getTime","type","clientId","timerId","taskId","timers","duration","toggleTimerPopup","setTimerPopupSize","setTimerPopupPosition","updateTimerStatus","updateCurrentTimerIfMatches","currentTimerId","extraReducers","builder","addCase","actions","fetchClientTimers","dispatch","errorMessage","Error","message","fetchTaskTimers","fetchRunningTimer","runningClientTimer","Object","values","find","timer","runningTaskTimer","hideTimerPopup","pauseTimer","console","startTimer","resumeTimer","stopTimer","reset","reducer"],"sources":["C:/Users/Steve/Documents/Dernier projet task manager/task-manager-complete-main (1)/task-manager-complete-main/frontend/src/store/slices/timerSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction, createAction, Dispatch } from '@reduxjs/toolkit';\r\nimport { RootState } from '..';\r\n\r\n// Définition des interfaces pour les types\r\nexport interface Timer {\r\n  _id: string;\r\n  duration: number;\r\n  isRunning: boolean;\r\n  startTime?: Date;\r\n  taskId?: string;\r\n  clientId?: string;\r\n}\r\n\r\ninterface TimerState {\r\n  clientTimers: Record<string, Timer>;\r\n  taskTimers: Record<string, Timer>;\r\n  currentTimer: Timer | null;\r\n  runningTimer: Timer | null;\r\n  showTimerPopup: boolean; // Assurez-vous que cette ligne existe\r\n  timerPopupSize: 'small' | 'medium' | 'large';\r\n  timerPopupPosition: 'top-right' | 'bottom-right' | 'center';\r\n  loading: boolean;\r\n  error: string | null;\r\n}\r\n\r\n// Définition du type AppThunk si non exporté depuis '..'\r\nexport type AppThunk = (dispatch: Dispatch, getState: () => RootState) => void;\r\n\r\n// Fonction utilitaire pour gérer les dates potentiellement undefined\r\nconst safeDate = (date: Date | undefined | null): Date => {\r\n  if (!date) return new Date();\r\n  try {\r\n    return new Date(date instanceof Date ? date : new Date(date));\r\n  } catch (error) {\r\n    return new Date();\r\n  }\r\n};\r\n\r\n// Simuler les fonctions d'API si elles ne sont pas disponibles\r\n// Ces fonctions devraient être remplacées par les véritables implémentations\r\nconst fetchClientTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\nconst fetchTaskTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\n// État initial\r\nconst initialState: TimerState = {\r\n  clientTimers: {},\r\n  taskTimers: {},\r\n  currentTimer: null,\r\n  runningTimer: null,\r\n  showTimerPopup: false, // Assurez-vous que cette ligne existe\r\n  timerPopupSize: 'medium',\r\n  timerPopupPosition: 'bottom-right',\r\n  loading: false,\r\n  error: null\r\n};\r\n\r\n// Actions pour les opérations asynchrones\r\nconst fetchClientTimersPending = createAction('timer/fetchClientTimers/pending');\r\nconst fetchClientTimersFulfilled = createAction<Record<string, Timer>>('timer/fetchClientTimers/fulfilled');\r\nconst fetchClientTimersRejected = createAction<string>('timer/fetchClientTimers/rejected');\r\n\r\nconst fetchTaskTimersPending = createAction('timer/fetchTaskTimers/pending');\r\nconst fetchTaskTimersFulfilled = createAction<Record<string, Timer>>('timer/fetchTaskTimers/fulfilled');\r\nconst fetchTaskTimersRejected = createAction<string>('timer/fetchTaskTimers/rejected');\r\n\r\nconst fetchRunningTimerPending = createAction('timer/fetchRunningTimer/pending');\r\nconst fetchRunningTimerFulfilled = createAction('timer/fetchRunningTimer/fulfilled');\r\nconst fetchRunningTimerRejected = createAction<string>('timer/fetchRunningTimer/rejected');\r\n\r\n// Création du slice\r\nconst timerSlice = createSlice({\r\n  name: 'timer',\r\n  initialState,\r\n  reducers: {\r\n    // Définir le timer actuel\r\n    setCurrentTimer: (state, action: PayloadAction<Timer | null>) => {\r\n      state.currentTimer = action.payload;\r\n    },\r\n\r\n    // Définir le timer en cours d'exécution\r\n    setRunningTimer: (state, action: PayloadAction<Timer | null>) => {\r\n      state.runningTimer = action.payload;\r\n    },\r\n\r\n    // Mettre à jour la durée d'un timer en cours\r\n    updateRunningTimerDuration: (state) => {\r\n      if (state.currentTimer && state.currentTimer.isRunning && state.currentTimer.startTime) {\r\n        // Utiliser safeDate pour éviter l'erreur TypeScript\r\n        const startTime = safeDate(state.currentTimer.startTime);\r\n        const currentTime = new Date();\r\n        const elapsedTime = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);\r\n\r\n        const type = state.currentTimer.clientId ? 'client' : 'task';\r\n        const timerId = state.currentTimer.clientId || state.currentTimer.taskId;\r\n\r\n        if (timerId) {\r\n          const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n          if (timers[timerId]) {\r\n            timers[timerId].duration = elapsedTime;\r\n            state.currentTimer.duration = elapsedTime;\r\n\r\n            // Mettre à jour également runningTimer si c'est le même timer\r\n            if (state.runningTimer &&\r\n              ((type === 'client' && state.runningTimer.clientId === timerId) ||\r\n                (type === 'task' && state.runningTimer.taskId === timerId))) {\r\n              state.runningTimer.duration = elapsedTime;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Afficher/masquer la popup de timer\r\n    toggleTimerPopup: (state, action: PayloadAction<boolean>) => {\r\n      state.showTimerPopup = action.payload; // Assurez-vous que cette ligne existe\r\n    },\r\n\r\n    // Définir la taille de la popup de timer\r\n    setTimerPopupSize: (state, action: PayloadAction<'small' | 'medium' | 'large'>) => {\r\n      state.timerPopupSize = action.payload;\r\n    },\r\n\r\n    // Définir la position de la popup de timer\r\n    setTimerPopupPosition: (state, action: PayloadAction<'top-right' | 'bottom-right' | 'center'>) => {\r\n      state.timerPopupPosition = action.payload;\r\n    },\r\n\r\n    // Mettre à jour le statut d'un timer\r\n    updateTimerStatus: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task'; isRunning: boolean }>) => {\r\n      const { timerId, type, isRunning } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].isRunning = isRunning;\r\n        if (isRunning) {\r\n          timers[timerId].startTime = new Date();\r\n\r\n          // Si le timer est démarré, le définir comme runningTimer\r\n          state.runningTimer = timers[timerId];\r\n        } else if (state.runningTimer &&\r\n          ((type === 'client' && state.runningTimer.clientId === timerId) ||\r\n            (type === 'task' && state.runningTimer.taskId === timerId))) {\r\n          // Si le timer est arrêté et qu'il s'agit du runningTimer, réinitialiser runningTimer\r\n          state.runningTimer = null;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Mettre à jour le timer actuel s'il correspond\r\n    updateCurrentTimerIfMatches: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task'; isRunning: boolean }>) => {\r\n      const { timerId, type, isRunning } = action.payload;\r\n\r\n      if (state.currentTimer) {\r\n        const currentTimerId = type === 'client' ? state.currentTimer.clientId : state.currentTimer.taskId;\r\n\r\n        if (currentTimerId === timerId) {\r\n          state.currentTimer.isRunning = isRunning;\r\n          if (isRunning) {\r\n            state.currentTimer.startTime = new Date();\r\n          }\r\n        }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Gestion des timers clients\r\n      .addCase(fetchClientTimersPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchClientTimersFulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.clientTimers = action.payload;\r\n      })\r\n      .addCase(fetchClientTimersRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n\r\n      // Gestion des timers de tâches\r\n      .addCase(fetchTaskTimersPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchTaskTimersFulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.taskTimers = action.payload;\r\n      })\r\n      .addCase(fetchTaskTimersRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n\r\n      // Gestion du timer en cours\r\n      .addCase(fetchRunningTimerPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchRunningTimerFulfilled, (state) => {\r\n        state.loading = false;\r\n      })\r\n      .addCase(fetchRunningTimerRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      });\r\n  }\r\n});\r\n\r\n// Export des actions\r\nexport const {\r\n  setCurrentTimer,\r\n  setRunningTimer,\r\n  updateRunningTimerDuration,\r\n  toggleTimerPopup,\r\n  setTimerPopupSize,\r\n  setTimerPopupPosition,\r\n  updateTimerStatus,\r\n  updateCurrentTimerIfMatches\r\n} = timerSlice.actions;\r\n\r\n// Thunks pour les opérations asynchrones\r\nexport const fetchClientTimers = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchClientTimersPending());\r\n    const clientTimers = await fetchClientTimersFromAPI();\r\n    dispatch(fetchClientTimersFulfilled(clientTimers));\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchClientTimersRejected(errorMessage));\r\n  }\r\n};\r\n\r\nexport const fetchTaskTimers = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchTaskTimersPending());\r\n    const taskTimers = await fetchTaskTimersFromAPI();\r\n    dispatch(fetchTaskTimersFulfilled(taskTimers));\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchTaskTimersRejected(errorMessage));\r\n  }\r\n};\r\n\r\nexport const fetchRunningTimer = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchRunningTimerPending());\r\n\r\n    // Vérifier d'abord les timers clients\r\n    const clientTimers = await fetchClientTimersFromAPI();\r\n    const runningClientTimer = Object.values(clientTimers).find(timer => timer.isRunning);\r\n\r\n    if (runningClientTimer) {\r\n      // Si un timer client est en cours d'exécution, le définir comme timer actuel et comme runningTimer\r\n      dispatch(setCurrentTimer(runningClientTimer));\r\n      dispatch(setRunningTimer(runningClientTimer));\r\n    } else {\r\n      // Sinon, vérifier les timers de tâches\r\n      const taskTimers = await fetchTaskTimersFromAPI();\r\n      const runningTaskTimer = Object.values(taskTimers).find(timer => timer.isRunning);\r\n\r\n      if (runningTaskTimer) {\r\n        dispatch(setCurrentTimer(runningTaskTimer));\r\n        dispatch(setRunningTimer(runningTaskTimer));\r\n      }\r\n    }\r\n\r\n    dispatch(fetchRunningTimerFulfilled());\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchRunningTimerRejected(errorMessage));\r\n  }\r\n};\r\n\r\n// Fonction hideTimerPopup ajoutée (utilise toggleTimerPopup avec false)\r\nexport const hideTimerPopup = (): AppThunk => (dispatch) => {\r\n  dispatch(toggleTimerPopup(false));\r\n};\r\n\r\n// Fonction pauseTimer ajoutée\r\nexport const pauseTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: false }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: false }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.pauseTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors de la mise en pause du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction startTimer ajoutée\r\nexport const startTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: true }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: true }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.startTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors du démarrage du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction resumeTimer ajoutée (identique à startTimer mais avec un nom différent)\r\nexport const resumeTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: true }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: true }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.resumeTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors de la reprise du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction stopTimer ajoutée (similaire à pauseTimer mais peut réinitialiser le timer)\r\nexport const stopTimer = (timerId: string, type: 'client' | 'task', reset: boolean = false): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: false }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: false }));\r\n\r\n    // Si reset est true, réinitialiser la durée du timer\r\n    if (reset) {\r\n      // Cette partie nécessiterait un nouveau reducer pour réinitialiser la durée\r\n      // Pour l'instant, nous nous contentons d'arrêter le timer\r\n    }\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.stopTimer(timerId, type, reset);\r\n  } catch (error) {\r\n    console.error('Erreur lors de l\\'arrêt du timer:', error);\r\n  }\r\n};\r\n\r\nexport default timerSlice.reducer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
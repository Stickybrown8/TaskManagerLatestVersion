{"ast":null,"code":"import{createSlice}from'@reduxjs/toolkit';import{fetchClientTimers,fetchTaskTimers}from'../../services/api';// Définition des interfaces pour les types\n// État initial\nconst initialState={clientTimers:{},taskTimers:{},currentTimer:null,showTimerPopup:false,timerPopupSize:'medium',timerPopupPosition:'bottom-right',loading:false,error:null};// Création du slice\nconst timerSlice=createSlice({name:'timer',initialState,reducers:{// Actions pour les timers clients\nfetchClientTimers:{pending:state=>{state.loading=true;state.error=null;},fulfilled:(state,action)=>{state.loading=false;state.clientTimers=action.payload;},rejected:(state,action)=>{state.loading=false;state.error=action.payload;}},// Actions pour les timers de tâches\nfetchTaskTimers:{pending:state=>{state.loading=true;state.error=null;},fulfilled:(state,action)=>{state.loading=false;state.taskTimers=action.payload;},rejected:(state,action)=>{state.loading=false;state.error=action.payload;}},// Démarrer un timer\nstartTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].isRunning=true;timers[timerId].startTime=new Date();state.currentTimer=timers[timerId];}},// Arrêter un timer\nstopTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]&&timers[timerId].isRunning){timers[timerId].isRunning=false;// Calculer la durée écoulée si startTime existe\nif(timers[timerId].startTime){const startTime=new Date(timers[timerId].startTime);const endTime=new Date();const elapsedTime=Math.floor((endTime.getTime()-startTime.getTime())/1000);timers[timerId].duration+=elapsedTime;}if(state.currentTimer&&state.currentTimer._id===timerId){state.currentTimer=null;}}},// Mettre à jour la durée d'un timer en cours\nupdateRunningTimerDuration:state=>{if(state.currentTimer&&state.currentTimer.isRunning&&state.currentTimer.startTime){const startTime=new Date(state.currentTimer.startTime);const currentTime=new Date();const elapsedTime=Math.floor((currentTime.getTime()-startTime.getTime())/1000);const type=state.currentTimer.clientId?'client':'task';const timerId=state.currentTimer.clientId||state.currentTimer.taskId;if(timerId){const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].duration=elapsedTime;state.currentTimer.duration=elapsedTime;}}}},// Réinitialiser un timer\nresetTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].duration=0;timers[timerId].isRunning=false;timers[timerId].startTime=undefined;if(state.currentTimer&&state.currentTimer._id===timerId){state.currentTimer=null;}}},// Définir le timer actuel\nsetCurrentTimer:(state,action)=>{state.currentTimer=action.payload;},// Afficher/masquer la popup du timer\nshowTimerPopup:state=>{state.showTimerPopup=true;},hideTimerPopup:state=>{state.showTimerPopup=false;},// Définir la taille de la popup du timer\nsetTimerPopupSize:(state,action)=>{state.timerPopupSize=action.payload;},// Définir la position de la popup du timer\nsetTimerPopupPosition:(state,action)=>{state.timerPopupPosition=action.payload;},// Gérer les erreurs\nclearTimerError:state=>{state.error=null;}}});// Export des actions\nexport const{clearTimerError,setCurrentTimer,clearCurrentTimer,showTimerPopup,hideTimerPopup,setTimerPopupSize,setTimerPopupPosition,updateRunningTimerDuration}=timerSlice.actions;// Export du reducer\nexport default timerSlice.reducer;// Thunks pour les opérations asynchrones\nexport const fetchClientTimersAsync=()=>async dispatch=>{try{dispatch(timerSlice.actions.fetchClientTimers.pending());const timers=await fetchClientTimers();dispatch(timerSlice.actions.fetchClientTimers.fulfilled(timers));}catch(error){dispatch(timerSlice.actions.fetchClientTimers.rejected(error.toString()));}};export const fetchTaskTimersAsync=()=>async dispatch=>{try{dispatch(timerSlice.actions.fetchTaskTimers.pending());const timers=await fetchTaskTimers();dispatch(timerSlice.actions.fetchTaskTimers.fulfilled(timers));}catch(error){dispatch(timerSlice.actions.fetchTaskTimers.rejected(error.toString()));}};","map":{"version":3,"names":["createSlice","fetchClientTimers","fetchTaskTimers","initialState","clientTimers","taskTimers","currentTimer","showTimerPopup","timerPopupSize","timerPopupPosition","loading","error","timerSlice","name","reducers","pending","state","fulfilled","action","payload","rejected","startTimer","timerId","type","timers","isRunning","startTime","Date","stopTimer","endTime","elapsedTime","Math","floor","getTime","duration","_id","updateRunningTimerDuration","currentTime","clientId","taskId","resetTimer","undefined","setCurrentTimer","hideTimerPopup","setTimerPopupSize","setTimerPopupPosition","clearTimerError","clearCurrentTimer","actions","reducer","fetchClientTimersAsync","dispatch","toString","fetchTaskTimersAsync"],"sources":["C:/Users/Steve/Documents/Dernier projet task manager/task-manager-complete-main (1)/task-manager-complete-main/frontend/src/store/slices/timerSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport { AppThunk } from '..';\r\nimport { fetchClientTimers, fetchTaskTimers } from '../../services/api';\r\n\r\n// Définition des interfaces pour les types\r\ninterface Timer {\r\n  _id: string;\r\n  duration: number;\r\n  isRunning: boolean;\r\n  startTime?: Date;\r\n  taskId?: string;\r\n  clientId?: string;\r\n}\r\n\r\ninterface TimerState {\r\n  clientTimers: Record<string, Timer>;\r\n  taskTimers: Record<string, Timer>;\r\n  currentTimer: Timer | null;\r\n  showTimerPopup: boolean;\r\n  timerPopupSize: 'small' | 'medium' | 'large';\r\n  timerPopupPosition: 'top-right' | 'bottom-right' | 'center';\r\n  loading: boolean;\r\n  error: string | null;\r\n}\r\n\r\n// État initial\r\nconst initialState: TimerState = {\r\n  clientTimers: {},\r\n  taskTimers: {},\r\n  currentTimer: null,\r\n  showTimerPopup: false,\r\n  timerPopupSize: 'medium',\r\n  timerPopupPosition: 'bottom-right',\r\n  loading: false,\r\n  error: null\r\n};\r\n\r\n// Création du slice\r\nconst timerSlice = createSlice({\r\n  name: 'timer',\r\n  initialState,\r\n  reducers: {\r\n    // Actions pour les timers clients\r\n    fetchClientTimers: {\r\n      pending: (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      },\r\n      fulfilled: (state, action: PayloadAction<Record<string, Timer>>) => {\r\n        state.loading = false;\r\n        state.clientTimers = action.payload;\r\n      },\r\n      rejected: (state, action: PayloadAction<string>) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      }\r\n    },\r\n\r\n    // Actions pour les timers de tâches\r\n    fetchTaskTimers: {\r\n      pending: (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      },\r\n      fulfilled: (state, action: PayloadAction<Record<string, Timer>>) => {\r\n        state.loading = false;\r\n        state.taskTimers = action.payload;\r\n      },\r\n      rejected: (state, action: PayloadAction<string>) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      }\r\n    },\r\n\r\n    // Démarrer un timer\r\n    startTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].isRunning = true;\r\n        timers[timerId].startTime = new Date();\r\n        state.currentTimer = timers[timerId];\r\n      }\r\n    },\r\n\r\n    // Arrêter un timer\r\n    stopTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId] && timers[timerId].isRunning) {\r\n        timers[timerId].isRunning = false;\r\n\r\n        // Calculer la durée écoulée si startTime existe\r\n        if (timers[timerId].startTime) {\r\n          const startTime = new Date(timers[timerId].startTime);\r\n          const endTime = new Date();\r\n          const elapsedTime = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);\r\n          timers[timerId].duration += elapsedTime;\r\n        }\r\n\r\n        if (state.currentTimer && state.currentTimer._id === timerId) {\r\n          state.currentTimer = null;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Mettre à jour la durée d'un timer en cours\r\n    updateRunningTimerDuration: (state) => {\r\n      if (state.currentTimer && state.currentTimer.isRunning && state.currentTimer.startTime) {\r\n        const startTime = new Date(state.currentTimer.startTime);\r\n        const currentTime = new Date();\r\n        const elapsedTime = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);\r\n\r\n        const type = state.currentTimer.clientId ? 'client' : 'task';\r\n        const timerId = state.currentTimer.clientId || state.currentTimer.taskId;\r\n\r\n        if (timerId) {\r\n          const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n          if (timers[timerId]) {\r\n            timers[timerId].duration = elapsedTime;\r\n            state.currentTimer.duration = elapsedTime;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Réinitialiser un timer\r\n    resetTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].duration = 0;\r\n        timers[timerId].isRunning = false;\r\n        timers[timerId].startTime = undefined;\r\n\r\n        if (state.currentTimer && state.currentTimer._id === timerId) {\r\n          state.currentTimer = null;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Définir le timer actuel\r\n    setCurrentTimer: (state, action: PayloadAction<Timer | null>) => {\r\n      state.currentTimer = action.payload;\r\n    },\r\n\r\n    // Afficher/masquer la popup du timer\r\n    showTimerPopup: (state) => {\r\n      state.showTimerPopup = true;\r\n    },\r\n    hideTimerPopup: (state) => {\r\n      state.showTimerPopup = false;\r\n    },\r\n\r\n    // Définir la taille de la popup du timer\r\n    setTimerPopupSize: (state, action: PayloadAction<'small' | 'medium' | 'large'>) => {\r\n      state.timerPopupSize = action.payload;\r\n    },\r\n\r\n    // Définir la position de la popup du timer\r\n    setTimerPopupPosition: (state, action: PayloadAction<'top-right' | 'bottom-right' | 'center'>) => {\r\n      state.timerPopupPosition = action.payload;\r\n    },\r\n\r\n    // Gérer les erreurs\r\n    clearTimerError: (state) => {\r\n      state.error = null;\r\n    }\r\n  }\r\n});\r\n\r\n// Export des actions\r\nexport const {\r\n  clearTimerError,\r\n  setCurrentTimer,\r\n  clearCurrentTimer,\r\n  showTimerPopup,\r\n  hideTimerPopup,\r\n  setTimerPopupSize,\r\n  setTimerPopupPosition,\r\n  updateRunningTimerDuration\r\n} = timerSlice.actions;\r\n\r\n// Export du reducer\r\nexport default timerSlice.reducer;\r\n\r\n// Thunks pour les opérations asynchrones\r\nexport const fetchClientTimersAsync = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(timerSlice.actions.fetchClientTimers.pending());\r\n    const timers = await fetchClientTimers();\r\n    dispatch(timerSlice.actions.fetchClientTimers.fulfilled(timers));\r\n  } catch (error) {\r\n    dispatch(timerSlice.actions.fetchClientTimers.rejected(error.toString()));\r\n  }\r\n};\r\n\r\nexport const fetchTaskTimersAsync = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(timerSlice.actions.fetchTaskTimers.pending());\r\n    const timers = await fetchTaskTimers();\r\n    dispatch(timerSlice.actions.fetchTaskTimers.fulfilled(timers));\r\n  } catch (error) {\r\n    dispatch(timerSlice.actions.fetchTaskTimers.rejected(error.toString()));\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
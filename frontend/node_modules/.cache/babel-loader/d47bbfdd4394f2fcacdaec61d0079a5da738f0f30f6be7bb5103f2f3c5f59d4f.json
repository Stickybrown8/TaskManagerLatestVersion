{"ast":null,"code":"import{createSlice,createAsyncThunk}from'@reduxjs/toolkit';// Définition des interfaces pour les types\n// Définition du type AppThunk si non exporté depuis '..'\n// Simuler les fonctions d'API si elles ne sont pas disponibles\n// Ces fonctions devraient être remplacées par les véritables implémentations\nconst fetchClientTimersFromAPI=async()=>{// Simulation - à remplacer par l'appel API réel\nreturn{};};const fetchTaskTimersFromAPI=async()=>{// Simulation - à remplacer par l'appel API réel\nreturn{};};// État initial\nconst initialState={clientTimers:{},taskTimers:{},currentTimer:null,showTimerPopup:false,timerPopupSize:'medium',timerPopupPosition:'bottom-right',loading:false,error:null};// Création des thunks asynchrones avec createAsyncThunk\nexport const fetchClientTimersAsync=createAsyncThunk('timer/fetchClientTimers',async(_,_ref)=>{let{rejectWithValue}=_ref;try{return await fetchClientTimersFromAPI();}catch(error){return rejectWithValue(error instanceof Error?error.message:'Une erreur est survenue');}});export const fetchTaskTimersAsync=createAsyncThunk('timer/fetchTaskTimers',async(_,_ref2)=>{let{rejectWithValue}=_ref2;try{return await fetchTaskTimersFromAPI();}catch(error){return rejectWithValue(error instanceof Error?error.message:'Une erreur est survenue');}});// Fonction utilitaire pour gérer les dates potentiellement undefined\nconst safeDate=date=>{return date?new Date(date.getTime()):new Date();};// Création du slice\nconst timerSlice=createSlice({name:'timer',initialState,reducers:{// Démarrer un timer\nstartTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].isRunning=true;timers[timerId].startTime=new Date();state.currentTimer=timers[timerId];}},// Arrêter un timer\nstopTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]&&timers[timerId].isRunning){timers[timerId].isRunning=false;// Calculer la durée écoulée si startTime existe\nif(timers[timerId].startTime){// Utilisation de la fonction safeDate pour éviter les problèmes avec undefined\nconst startTime=safeDate(timers[timerId].startTime);const endTime=new Date();const elapsedTime=Math.floor((endTime.getTime()-startTime.getTime())/1000);timers[timerId].duration+=elapsedTime;}if(state.currentTimer&&state.currentTimer._id===timerId){state.currentTimer=null;}}},// Mettre à jour la durée d'un timer en cours\nupdateRunningTimerDuration:state=>{if(state.currentTimer&&state.currentTimer.isRunning&&state.currentTimer.startTime){// Utilisation de la fonction safeDate pour éviter les problèmes avec undefined\nconst startTime=safeDate(state.currentTimer.startTime);const currentTime=new Date();const elapsedTime=Math.floor((currentTime.getTime()-startTime.getTime())/1000);const type=state.currentTimer.clientId?'client':'task';const timerId=state.currentTimer.clientId||state.currentTimer.taskId;if(timerId){const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].duration=elapsedTime;state.currentTimer.duration=elapsedTime;}}}},// Réinitialiser un timer\nresetTimer:(state,action)=>{const{timerId,type}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].duration=0;timers[timerId].isRunning=false;timers[timerId].startTime=undefined;if(state.currentTimer&&state.currentTimer._id===timerId){state.currentTimer=null;}}},// Définir le timer actuel\nsetCurrentTimer:(state,action)=>{state.currentTimer=action.payload;},// Effacer le timer actuel\nclearCurrentTimer:state=>{state.currentTimer=null;},// Afficher/masquer la popup du timer\nshowTimerPopup:state=>{state.showTimerPopup=true;},hideTimerPopup:state=>{state.showTimerPopup=false;},// Définir la taille de la popup du timer\nsetTimerPopupSize:(state,action)=>{state.timerPopupSize=action.payload;},// Définir la position de la popup du timer\nsetTimerPopupPosition:(state,action)=>{state.timerPopupPosition=action.payload;},// Gérer les erreurs\nclearTimerError:state=>{state.error=null;}},extraReducers:builder=>{// Gestion des états pour fetchClientTimersAsync\nbuilder.addCase(fetchClientTimersAsync.pending,state=>{state.loading=true;state.error=null;}).addCase(fetchClientTimersAsync.fulfilled,(state,action)=>{state.loading=false;state.clientTimers=action.payload;}).addCase(fetchClientTimersAsync.rejected,(state,action)=>{state.loading=false;state.error=action.payload||'Une erreur est survenue';})// Gestion des états pour fetchTaskTimersAsync\n.addCase(fetchTaskTimersAsync.pending,state=>{state.loading=true;state.error=null;}).addCase(fetchTaskTimersAsync.fulfilled,(state,action)=>{state.loading=false;state.taskTimers=action.payload;}).addCase(fetchTaskTimersAsync.rejected,(state,action)=>{state.loading=false;state.error=action.payload||'Une erreur est survenue';});}});// Export des actions\nexport const{startTimer,stopTimer,resetTimer,clearTimerError,setCurrentTimer,clearCurrentTimer,showTimerPopup,hideTimerPopup,setTimerPopupSize,setTimerPopupPosition,updateRunningTimerDuration}=timerSlice.actions;// Export du reducer\nexport default timerSlice.reducer;// Fonction fetchRunningTimer manquante\nexport const fetchRunningTimer=()=>async(dispatch,getState)=>{try{dispatch({type:'timer/fetchRunningTimer/pending'});// Récupérer tous les timers clients\nconst clientTimers=await fetchClientTimersFromAPI();// Chercher un timer en cours d'exécution\nconst runningClientTimer=Object.values(clientTimers).find(timer=>timer.isRunning);if(runningClientTimer){// Si un timer client est en cours d'exécution, le définir comme timer actuel\ndispatch(setCurrentTimer(runningClientTimer));}else{// Sinon, vérifier les timers de tâches\nconst taskTimers=await fetchTaskTimersFromAPI();const runningTaskTimer=Object.values(taskTimers).find(timer=>timer.isRunning);if(runningTaskTimer){dispatch(setCurrentTimer(runningTaskTimer));}}dispatch({type:'timer/fetchRunningTimer/fulfilled'});}catch(error){const errorMessage=error instanceof Error?error.message:'Une erreur est survenue';dispatch({type:'timer/fetchRunningTimer/rejected',payload:errorMessage});}};","map":{"version":3,"names":["createSlice","createAsyncThunk","fetchClientTimersFromAPI","fetchTaskTimersFromAPI","initialState","clientTimers","taskTimers","currentTimer","showTimerPopup","timerPopupSize","timerPopupPosition","loading","error","fetchClientTimersAsync","_","_ref","rejectWithValue","Error","message","fetchTaskTimersAsync","_ref2","safeDate","date","Date","getTime","timerSlice","name","reducers","startTimer","state","action","timerId","type","payload","timers","isRunning","startTime","stopTimer","endTime","elapsedTime","Math","floor","duration","_id","updateRunningTimerDuration","currentTime","clientId","taskId","resetTimer","undefined","setCurrentTimer","clearCurrentTimer","hideTimerPopup","setTimerPopupSize","setTimerPopupPosition","clearTimerError","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","fetchRunningTimer","dispatch","getState","runningClientTimer","Object","values","find","timer","runningTaskTimer","errorMessage"],"sources":["C:/Users/Steve/Documents/Dernier projet task manager/task-manager-complete-main (1)/task-manager-complete-main/frontend/src/store/slices/timerSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction, createAsyncThunk, Dispatch } from '@reduxjs/toolkit';\r\nimport { RootState } from '..';\r\n\r\n// Définition des interfaces pour les types\r\nexport interface Timer {\r\n  _id: string;\r\n  duration: number;\r\n  isRunning: boolean;\r\n  startTime?: Date;\r\n  taskId?: string;\r\n  clientId?: string;\r\n}\r\n\r\ninterface TimerState {\r\n  clientTimers: Record<string, Timer>;\r\n  taskTimers: Record<string, Timer>;\r\n  currentTimer: Timer | null;\r\n  showTimerPopup: boolean;\r\n  timerPopupSize: 'small' | 'medium' | 'large';\r\n  timerPopupPosition: 'top-right' | 'bottom-right' | 'center';\r\n  loading: boolean;\r\n  error: string | null;\r\n}\r\n\r\n// Définition du type AppThunk si non exporté depuis '..'\r\nexport type AppThunk = (dispatch: Dispatch, getState: () => RootState) => void;\r\n\r\n// Simuler les fonctions d'API si elles ne sont pas disponibles\r\n// Ces fonctions devraient être remplacées par les véritables implémentations\r\nconst fetchClientTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\nconst fetchTaskTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\n// État initial\r\nconst initialState: TimerState = {\r\n  clientTimers: {},\r\n  taskTimers: {},\r\n  currentTimer: null,\r\n  showTimerPopup: false,\r\n  timerPopupSize: 'medium',\r\n  timerPopupPosition: 'bottom-right',\r\n  loading: false,\r\n  error: null\r\n};\r\n\r\n// Création des thunks asynchrones avec createAsyncThunk\r\nexport const fetchClientTimersAsync = createAsyncThunk(\r\n  'timer/fetchClientTimers',\r\n  async (_, { rejectWithValue }) => {\r\n    try {\r\n      return await fetchClientTimersFromAPI();\r\n    } catch (error) {\r\n      return rejectWithValue(error instanceof Error ? error.message : 'Une erreur est survenue');\r\n    }\r\n  }\r\n);\r\n\r\nexport const fetchTaskTimersAsync = createAsyncThunk(\r\n  'timer/fetchTaskTimers',\r\n  async (_, { rejectWithValue }) => {\r\n    try {\r\n      return await fetchTaskTimersFromAPI();\r\n    } catch (error) {\r\n      return rejectWithValue(error instanceof Error ? error.message : 'Une erreur est survenue');\r\n    }\r\n  }\r\n);\r\n\r\n// Fonction utilitaire pour gérer les dates potentiellement undefined\r\nconst safeDate = (date: Date | undefined): Date => {\r\n  return date ? new Date(date.getTime()) : new Date();\r\n};\r\n\r\n// Création du slice\r\nconst timerSlice = createSlice({\r\n  name: 'timer',\r\n  initialState,\r\n  reducers: {\r\n    // Démarrer un timer\r\n    startTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].isRunning = true;\r\n        timers[timerId].startTime = new Date();\r\n        state.currentTimer = timers[timerId];\r\n      }\r\n    },\r\n\r\n    // Arrêter un timer\r\n    stopTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId] && timers[timerId].isRunning) {\r\n        timers[timerId].isRunning = false;\r\n\r\n        // Calculer la durée écoulée si startTime existe\r\n        if (timers[timerId].startTime) {\r\n          // Utilisation de la fonction safeDate pour éviter les problèmes avec undefined\r\n          const startTime = safeDate(timers[timerId].startTime);\r\n          const endTime = new Date();\r\n          const elapsedTime = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);\r\n          timers[timerId].duration += elapsedTime;\r\n        }\r\n\r\n        if (state.currentTimer && state.currentTimer._id === timerId) {\r\n          state.currentTimer = null;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Mettre à jour la durée d'un timer en cours\r\n    updateRunningTimerDuration: (state) => {\r\n      if (state.currentTimer && state.currentTimer.isRunning && state.currentTimer.startTime) {\r\n        // Utilisation de la fonction safeDate pour éviter les problèmes avec undefined\r\n        const startTime = safeDate(state.currentTimer.startTime);\r\n        const currentTime = new Date();\r\n        const elapsedTime = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);\r\n\r\n        const type = state.currentTimer.clientId ? 'client' : 'task';\r\n        const timerId = state.currentTimer.clientId || state.currentTimer.taskId;\r\n\r\n        if (timerId) {\r\n          const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n          if (timers[timerId]) {\r\n            timers[timerId].duration = elapsedTime;\r\n            state.currentTimer.duration = elapsedTime;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Réinitialiser un timer\r\n    resetTimer: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task' }>) => {\r\n      const { timerId, type } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].duration = 0;\r\n        timers[timerId].isRunning = false;\r\n        timers[timerId].startTime = undefined;\r\n\r\n        if (state.currentTimer && state.currentTimer._id === timerId) {\r\n          state.currentTimer = null;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Définir le timer actuel\r\n    setCurrentTimer: (state, action: PayloadAction<Timer | null>) => {\r\n      state.currentTimer = action.payload;\r\n    },\r\n\r\n    // Effacer le timer actuel\r\n    clearCurrentTimer: (state) => {\r\n      state.currentTimer = null;\r\n    },\r\n\r\n    // Afficher/masquer la popup du timer\r\n    showTimerPopup: (state) => {\r\n      state.showTimerPopup = true;\r\n    },\r\n    hideTimerPopup: (state) => {\r\n      state.showTimerPopup = false;\r\n    },\r\n\r\n    // Définir la taille de la popup du timer\r\n    setTimerPopupSize: (state, action: PayloadAction<'small' | 'medium' | 'large'>) => {\r\n      state.timerPopupSize = action.payload;\r\n    },\r\n\r\n    // Définir la position de la popup du timer\r\n    setTimerPopupPosition: (state, action: PayloadAction<'top-right' | 'bottom-right' | 'center'>) => {\r\n      state.timerPopupPosition = action.payload;\r\n    },\r\n\r\n    // Gérer les erreurs\r\n    clearTimerError: (state) => {\r\n      state.error = null;\r\n    }\r\n  },\r\n  extraReducers: (builder) => {\r\n    // Gestion des états pour fetchClientTimersAsync\r\n    builder\r\n      .addCase(fetchClientTimersAsync.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchClientTimersAsync.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.clientTimers = action.payload;\r\n      })\r\n      .addCase(fetchClientTimersAsync.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload as string || 'Une erreur est survenue';\r\n      })\r\n      // Gestion des états pour fetchTaskTimersAsync\r\n      .addCase(fetchTaskTimersAsync.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchTaskTimersAsync.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.taskTimers = action.payload;\r\n      })\r\n      .addCase(fetchTaskTimersAsync.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload as string || 'Une erreur est survenue';\r\n      });\r\n  }\r\n});\r\n\r\n// Export des actions\r\nexport const {\r\n  startTimer,\r\n  stopTimer,\r\n  resetTimer,\r\n  clearTimerError,\r\n  setCurrentTimer,\r\n  clearCurrentTimer,\r\n  showTimerPopup,\r\n  hideTimerPopup,\r\n  setTimerPopupSize,\r\n  setTimerPopupPosition,\r\n  updateRunningTimerDuration\r\n} = timerSlice.actions;\r\n\r\n// Export du reducer\r\nexport default timerSlice.reducer;\r\n\r\n// Fonction fetchRunningTimer manquante\r\nexport const fetchRunningTimer = (): AppThunk => async (dispatch, getState) => {\r\n  try {\r\n    dispatch({ type: 'timer/fetchRunningTimer/pending' });\r\n\r\n    // Récupérer tous les timers clients\r\n    const clientTimers = await fetchClientTimersFromAPI();\r\n\r\n    // Chercher un timer en cours d'exécution\r\n    const runningClientTimer = Object.values(clientTimers).find(timer => timer.isRunning);\r\n\r\n    if (runningClientTimer) {\r\n      // Si un timer client est en cours d'exécution, le définir comme timer actuel\r\n      dispatch(setCurrentTimer(runningClientTimer));\r\n    } else {\r\n      // Sinon, vérifier les timers de tâches\r\n      const taskTimers = await fetchTaskTimersFromAPI();\r\n      const runningTaskTimer = Object.values(taskTimers).find(timer => timer.isRunning);\r\n\r\n      if (runningTaskTimer) {\r\n        dispatch(setCurrentTimer(runningTaskTimer));\r\n      }\r\n    }\r\n\r\n    dispatch({ type: 'timer/fetchRunningTimer/fulfilled' });\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch({ type: 'timer/fetchRunningTimer/rejected', payload: errorMessage });\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import{createSlice,createAction}from'@reduxjs/toolkit';// Définition des interfaces pour les types\n// Définition du type AppThunk si non exporté depuis '..'\n// Fonction utilitaire pour gérer les dates potentiellement undefined\nconst safeDate=date=>{if(!date)return new Date();try{return new Date(date instanceof Date?date:new Date(date));}catch(error){return new Date();}};// Simuler les fonctions d'API si elles ne sont pas disponibles\n// Ces fonctions devraient être remplacées par les véritables implémentations\nconst fetchClientTimersFromAPI=async()=>{// Simulation - à remplacer par l'appel API réel\nreturn{};};const fetchTaskTimersFromAPI=async()=>{// Simulation - à remplacer par l'appel API réel\nreturn{};};// État initial\nconst initialState={clientTimers:{},taskTimers:{},currentTimer:null,showTimerPopup:false,timerPopupSize:'medium',timerPopupPosition:'bottom-right',loading:false,error:null};// Actions pour les opérations asynchrones\nconst fetchClientTimersPending=createAction('timer/fetchClientTimers/pending');const fetchClientTimersFulfilled=createAction('timer/fetchClientTimers/fulfilled');const fetchClientTimersRejected=createAction('timer/fetchClientTimers/rejected');const fetchTaskTimersPending=createAction('timer/fetchTaskTimers/pending');const fetchTaskTimersFulfilled=createAction('timer/fetchTaskTimers/fulfilled');const fetchTaskTimersRejected=createAction('timer/fetchTaskTimers/rejected');const fetchRunningTimerPending=createAction('timer/fetchRunningTimer/pending');const fetchRunningTimerFulfilled=createAction('timer/fetchRunningTimer/fulfilled');const fetchRunningTimerRejected=createAction('timer/fetchRunningTimer/rejected');// Création du slice\nconst timerSlice=createSlice({name:'timer',initialState,reducers:{// Définir le timer actuel\nsetCurrentTimer:(state,action)=>{state.currentTimer=action.payload;},// Mettre à jour la durée d'un timer en cours\nupdateRunningTimerDuration:state=>{if(state.currentTimer&&state.currentTimer.isRunning&&state.currentTimer.startTime){// Utiliser safeDate pour éviter l'erreur TypeScript\nconst startTime=safeDate(state.currentTimer.startTime);const currentTime=new Date();const elapsedTime=Math.floor((currentTime.getTime()-startTime.getTime())/1000);const type=state.currentTimer.clientId?'client':'task';const timerId=state.currentTimer.clientId||state.currentTimer.taskId;if(timerId){const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].duration=elapsedTime;state.currentTimer.duration=elapsedTime;}}}},// Afficher/masquer la popup de timer\ntoggleTimerPopup:(state,action)=>{state.showTimerPopup=action.payload;},// Définir la taille de la popup de timer\nsetTimerPopupSize:(state,action)=>{state.timerPopupSize=action.payload;},// Définir la position de la popup de timer\nsetTimerPopupPosition:(state,action)=>{state.timerPopupPosition=action.payload;},// Mettre à jour le statut d'un timer\nupdateTimerStatus:(state,action)=>{const{timerId,type,isRunning}=action.payload;const timers=type==='client'?state.clientTimers:state.taskTimers;if(timers[timerId]){timers[timerId].isRunning=isRunning;if(isRunning){timers[timerId].startTime=new Date();}}},// Mettre à jour le timer actuel s'il correspond\nupdateCurrentTimerIfMatches:(state,action)=>{const{timerId,type,isRunning}=action.payload;if(state.currentTimer){const currentTimerId=type==='client'?state.currentTimer.clientId:state.currentTimer.taskId;if(currentTimerId===timerId){state.currentTimer.isRunning=isRunning;if(isRunning){state.currentTimer.startTime=new Date();}}}}},extraReducers:builder=>{builder// Gestion des timers clients\n.addCase(fetchClientTimersPending,state=>{state.loading=true;state.error=null;}).addCase(fetchClientTimersFulfilled,(state,action)=>{state.loading=false;state.clientTimers=action.payload;}).addCase(fetchClientTimersRejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Gestion des timers de tâches\n.addCase(fetchTaskTimersPending,state=>{state.loading=true;state.error=null;}).addCase(fetchTaskTimersFulfilled,(state,action)=>{state.loading=false;state.taskTimers=action.payload;}).addCase(fetchTaskTimersRejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Gestion du timer en cours\n.addCase(fetchRunningTimerPending,state=>{state.loading=true;state.error=null;}).addCase(fetchRunningTimerFulfilled,state=>{state.loading=false;}).addCase(fetchRunningTimerRejected,(state,action)=>{state.loading=false;state.error=action.payload;});}});// Export des actions\nexport const{setCurrentTimer,updateRunningTimerDuration,toggleTimerPopup,setTimerPopupSize,setTimerPopupPosition,updateTimerStatus,updateCurrentTimerIfMatches}=timerSlice.actions;// Thunks pour les opérations asynchrones\nexport const fetchClientTimers=()=>async dispatch=>{try{dispatch(fetchClientTimersPending());const clientTimers=await fetchClientTimersFromAPI();dispatch(fetchClientTimersFulfilled(clientTimers));}catch(error){const errorMessage=error instanceof Error?error.message:'Une erreur est survenue';dispatch(fetchClientTimersRejected(errorMessage));}};export const fetchTaskTimers=()=>async dispatch=>{try{dispatch(fetchTaskTimersPending());const taskTimers=await fetchTaskTimersFromAPI();dispatch(fetchTaskTimersFulfilled(taskTimers));}catch(error){const errorMessage=error instanceof Error?error.message:'Une erreur est survenue';dispatch(fetchTaskTimersRejected(errorMessage));}};export const fetchRunningTimer=()=>async dispatch=>{try{dispatch(fetchRunningTimerPending());// Vérifier d'abord les timers clients\nconst clientTimers=await fetchClientTimersFromAPI();const runningClientTimer=Object.values(clientTimers).find(timer=>timer.isRunning);if(runningClientTimer){// Si un timer client est en cours d'exécution, le définir comme timer actuel\ndispatch(setCurrentTimer(runningClientTimer));}else{// Sinon, vérifier les timers de tâches\nconst taskTimers=await fetchTaskTimersFromAPI();const runningTaskTimer=Object.values(taskTimers).find(timer=>timer.isRunning);if(runningTaskTimer){dispatch(setCurrentTimer(runningTaskTimer));}}dispatch(fetchRunningTimerFulfilled());}catch(error){const errorMessage=error instanceof Error?error.message:'Une erreur est survenue';dispatch(fetchRunningTimerRejected(errorMessage));}};// Fonction pauseTimer ajoutée\nexport const pauseTimer=(timerId,type)=>async dispatch=>{try{// Mettre à jour l'état local\ndispatch(updateTimerStatus({timerId,type,isRunning:false}));// Mettre à jour le timer actuel si c'est celui qui est en cours\ndispatch(updateCurrentTimerIfMatches({timerId,type,isRunning:false}));// Appel API pour mettre à jour le timer sur le serveur\n// Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n// await timerService.pauseTimer(timerId, type);\n}catch(error){console.error('Erreur lors de la mise en pause du timer:',error);}};// Fonction startTimer ajoutée\nexport const startTimer=(timerId,type)=>async dispatch=>{try{// Mettre à jour l'état local\ndispatch(updateTimerStatus({timerId,type,isRunning:true}));// Mettre à jour le timer actuel si c'est celui qui est en cours\ndispatch(updateCurrentTimerIfMatches({timerId,type,isRunning:true}));// Appel API pour mettre à jour le timer sur le serveur\n// Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n// await timerService.startTimer(timerId, type);\n}catch(error){console.error('Erreur lors du démarrage du timer:',error);}};// Fonction resumeTimer ajoutée (identique à startTimer mais avec un nom différent)\nexport const resumeTimer=(timerId,type)=>async dispatch=>{try{// Mettre à jour l'état local\ndispatch(updateTimerStatus({timerId,type,isRunning:true}));// Mettre à jour le timer actuel si c'est celui qui est en cours\ndispatch(updateCurrentTimerIfMatches({timerId,type,isRunning:true}));// Appel API pour mettre à jour le timer sur le serveur\n// Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n// await timerService.resumeTimer(timerId, type);\n}catch(error){console.error('Erreur lors de la reprise du timer:',error);}};// Fonction stopTimer ajoutée (similaire à pauseTimer mais peut réinitialiser le timer)\nexport const stopTimer=function(timerId,type){let reset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return async dispatch=>{try{// Mettre à jour l'état local\ndispatch(updateTimerStatus({timerId,type,isRunning:false}));// Mettre à jour le timer actuel si c'est celui qui est en cours\ndispatch(updateCurrentTimerIfMatches({timerId,type,isRunning:false}));// Si reset est true, réinitialiser la durée du timer\nif(reset){// Cette partie nécessiterait un nouveau reducer pour réinitialiser la durée\n// Pour l'instant, nous nous contentons d'arrêter le timer\n}// Appel API pour mettre à jour le timer sur le serveur\n// Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\n// await timerService.stopTimer(timerId, type, reset);\n}catch(error){console.error('Erreur lors de l\\'arrêt du timer:',error);}};};export default timerSlice.reducer;","map":{"version":3,"names":["createSlice","createAction","safeDate","date","Date","error","fetchClientTimersFromAPI","fetchTaskTimersFromAPI","initialState","clientTimers","taskTimers","currentTimer","showTimerPopup","timerPopupSize","timerPopupPosition","loading","fetchClientTimersPending","fetchClientTimersFulfilled","fetchClientTimersRejected","fetchTaskTimersPending","fetchTaskTimersFulfilled","fetchTaskTimersRejected","fetchRunningTimerPending","fetchRunningTimerFulfilled","fetchRunningTimerRejected","timerSlice","name","reducers","setCurrentTimer","state","action","payload","updateRunningTimerDuration","isRunning","startTime","currentTime","elapsedTime","Math","floor","getTime","type","clientId","timerId","taskId","timers","duration","toggleTimerPopup","setTimerPopupSize","setTimerPopupPosition","updateTimerStatus","updateCurrentTimerIfMatches","currentTimerId","extraReducers","builder","addCase","actions","fetchClientTimers","dispatch","errorMessage","Error","message","fetchTaskTimers","fetchRunningTimer","runningClientTimer","Object","values","find","timer","runningTaskTimer","pauseTimer","console","startTimer","resumeTimer","stopTimer","reset","arguments","length","undefined","reducer"],"sources":["C:/Users/Steve/Documents/Dernier projet task manager/task-manager-complete-main (1)/task-manager-complete-main/frontend/src/store/slices/timerSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction, createAction, Dispatch } from '@reduxjs/toolkit';\r\nimport { RootState } from '..';\r\n\r\n// Définition des interfaces pour les types\r\nexport interface Timer {\r\n  _id: string;\r\n  duration: number;\r\n  isRunning: boolean;\r\n  startTime?: Date;\r\n  taskId?: string;\r\n  clientId?: string;\r\n}\r\n\r\ninterface TimerState {\r\n  clientTimers: Record<string, Timer>;\r\n  taskTimers: Record<string, Timer>;\r\n  currentTimer: Timer | null;\r\n  showTimerPopup: boolean;\r\n  timerPopupSize: 'small' | 'medium' | 'large';\r\n  timerPopupPosition: 'top-right' | 'bottom-right' | 'center';\r\n  loading: boolean;\r\n  error: string | null;\r\n}\r\n\r\n// Définition du type AppThunk si non exporté depuis '..'\r\nexport type AppThunk = (dispatch: Dispatch, getState: () => RootState) => void;\r\n\r\n// Fonction utilitaire pour gérer les dates potentiellement undefined\r\nconst safeDate = (date: Date | undefined | null): Date => {\r\n  if (!date) return new Date();\r\n  try {\r\n    return new Date(date instanceof Date ? date : new Date(date));\r\n  } catch (error) {\r\n    return new Date();\r\n  }\r\n};\r\n\r\n// Simuler les fonctions d'API si elles ne sont pas disponibles\r\n// Ces fonctions devraient être remplacées par les véritables implémentations\r\nconst fetchClientTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\nconst fetchTaskTimersFromAPI = async (): Promise<Record<string, Timer>> => {\r\n  // Simulation - à remplacer par l'appel API réel\r\n  return {};\r\n};\r\n\r\n// État initial\r\nconst initialState: TimerState = {\r\n  clientTimers: {},\r\n  taskTimers: {},\r\n  currentTimer: null,\r\n  showTimerPopup: false,\r\n  timerPopupSize: 'medium',\r\n  timerPopupPosition: 'bottom-right',\r\n  loading: false,\r\n  error: null\r\n};\r\n\r\n// Actions pour les opérations asynchrones\r\nconst fetchClientTimersPending = createAction('timer/fetchClientTimers/pending');\r\nconst fetchClientTimersFulfilled = createAction<Record<string, Timer>>('timer/fetchClientTimers/fulfilled');\r\nconst fetchClientTimersRejected = createAction<string>('timer/fetchClientTimers/rejected');\r\n\r\nconst fetchTaskTimersPending = createAction('timer/fetchTaskTimers/pending');\r\nconst fetchTaskTimersFulfilled = createAction<Record<string, Timer>>('timer/fetchTaskTimers/fulfilled');\r\nconst fetchTaskTimersRejected = createAction<string>('timer/fetchTaskTimers/rejected');\r\n\r\nconst fetchRunningTimerPending = createAction('timer/fetchRunningTimer/pending');\r\nconst fetchRunningTimerFulfilled = createAction('timer/fetchRunningTimer/fulfilled');\r\nconst fetchRunningTimerRejected = createAction<string>('timer/fetchRunningTimer/rejected');\r\n\r\n// Création du slice\r\nconst timerSlice = createSlice({\r\n  name: 'timer',\r\n  initialState,\r\n  reducers: {\r\n    // Définir le timer actuel\r\n    setCurrentTimer: (state, action: PayloadAction<Timer | null>) => {\r\n      state.currentTimer = action.payload;\r\n    },\r\n\r\n    // Mettre à jour la durée d'un timer en cours\r\n    updateRunningTimerDuration: (state) => {\r\n      if (state.currentTimer && state.currentTimer.isRunning && state.currentTimer.startTime) {\r\n        // Utiliser safeDate pour éviter l'erreur TypeScript\r\n        const startTime = safeDate(state.currentTimer.startTime);\r\n        const currentTime = new Date();\r\n        const elapsedTime = Math.floor((currentTime.getTime() - startTime.getTime()) / 1000);\r\n\r\n        const type = state.currentTimer.clientId ? 'client' : 'task';\r\n        const timerId = state.currentTimer.clientId || state.currentTimer.taskId;\r\n\r\n        if (timerId) {\r\n          const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n          if (timers[timerId]) {\r\n            timers[timerId].duration = elapsedTime;\r\n            state.currentTimer.duration = elapsedTime;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Afficher/masquer la popup de timer\r\n    toggleTimerPopup: (state, action: PayloadAction<boolean>) => {\r\n      state.showTimerPopup = action.payload;\r\n    },\r\n\r\n    // Définir la taille de la popup de timer\r\n    setTimerPopupSize: (state, action: PayloadAction<'small' | 'medium' | 'large'>) => {\r\n      state.timerPopupSize = action.payload;\r\n    },\r\n\r\n    // Définir la position de la popup de timer\r\n    setTimerPopupPosition: (state, action: PayloadAction<'top-right' | 'bottom-right' | 'center'>) => {\r\n      state.timerPopupPosition = action.payload;\r\n    },\r\n\r\n    // Mettre à jour le statut d'un timer\r\n    updateTimerStatus: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task'; isRunning: boolean }>) => {\r\n      const { timerId, type, isRunning } = action.payload;\r\n      const timers = type === 'client' ? state.clientTimers : state.taskTimers;\r\n\r\n      if (timers[timerId]) {\r\n        timers[timerId].isRunning = isRunning;\r\n        if (isRunning) {\r\n          timers[timerId].startTime = new Date();\r\n        }\r\n      }\r\n    },\r\n\r\n    // Mettre à jour le timer actuel s'il correspond\r\n    updateCurrentTimerIfMatches: (state, action: PayloadAction<{ timerId: string; type: 'client' | 'task'; isRunning: boolean }>) => {\r\n      const { timerId, type, isRunning } = action.payload;\r\n\r\n      if (state.currentTimer) {\r\n        const currentTimerId = type === 'client' ? state.currentTimer.clientId : state.currentTimer.taskId;\r\n\r\n        if (currentTimerId === timerId) {\r\n          state.currentTimer.isRunning = isRunning;\r\n          if (isRunning) {\r\n            state.currentTimer.startTime = new Date();\r\n          }\r\n        }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Gestion des timers clients\r\n      .addCase(fetchClientTimersPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchClientTimersFulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.clientTimers = action.payload;\r\n      })\r\n      .addCase(fetchClientTimersRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n\r\n      // Gestion des timers de tâches\r\n      .addCase(fetchTaskTimersPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchTaskTimersFulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.taskTimers = action.payload;\r\n      })\r\n      .addCase(fetchTaskTimersRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n\r\n      // Gestion du timer en cours\r\n      .addCase(fetchRunningTimerPending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchRunningTimerFulfilled, (state) => {\r\n        state.loading = false;\r\n      })\r\n      .addCase(fetchRunningTimerRejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      });\r\n  }\r\n});\r\n\r\n// Export des actions\r\nexport const {\r\n  setCurrentTimer,\r\n  updateRunningTimerDuration,\r\n  toggleTimerPopup,\r\n  setTimerPopupSize,\r\n  setTimerPopupPosition,\r\n  updateTimerStatus,\r\n  updateCurrentTimerIfMatches\r\n} = timerSlice.actions;\r\n\r\n// Thunks pour les opérations asynchrones\r\nexport const fetchClientTimers = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchClientTimersPending());\r\n    const clientTimers = await fetchClientTimersFromAPI();\r\n    dispatch(fetchClientTimersFulfilled(clientTimers));\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchClientTimersRejected(errorMessage));\r\n  }\r\n};\r\n\r\nexport const fetchTaskTimers = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchTaskTimersPending());\r\n    const taskTimers = await fetchTaskTimersFromAPI();\r\n    dispatch(fetchTaskTimersFulfilled(taskTimers));\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchTaskTimersRejected(errorMessage));\r\n  }\r\n};\r\n\r\nexport const fetchRunningTimer = (): AppThunk => async (dispatch) => {\r\n  try {\r\n    dispatch(fetchRunningTimerPending());\r\n\r\n    // Vérifier d'abord les timers clients\r\n    const clientTimers = await fetchClientTimersFromAPI();\r\n    const runningClientTimer = Object.values(clientTimers).find(timer => timer.isRunning);\r\n\r\n    if (runningClientTimer) {\r\n      // Si un timer client est en cours d'exécution, le définir comme timer actuel\r\n      dispatch(setCurrentTimer(runningClientTimer));\r\n    } else {\r\n      // Sinon, vérifier les timers de tâches\r\n      const taskTimers = await fetchTaskTimersFromAPI();\r\n      const runningTaskTimer = Object.values(taskTimers).find(timer => timer.isRunning);\r\n\r\n      if (runningTaskTimer) {\r\n        dispatch(setCurrentTimer(runningTaskTimer));\r\n      }\r\n    }\r\n\r\n    dispatch(fetchRunningTimerFulfilled());\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Une erreur est survenue';\r\n    dispatch(fetchRunningTimerRejected(errorMessage));\r\n  }\r\n};\r\n\r\n// Fonction pauseTimer ajoutée\r\nexport const pauseTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: false }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: false }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.pauseTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors de la mise en pause du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction startTimer ajoutée\r\nexport const startTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: true }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: true }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.startTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors du démarrage du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction resumeTimer ajoutée (identique à startTimer mais avec un nom différent)\r\nexport const resumeTimer = (timerId: string, type: 'client' | 'task'): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: true }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: true }));\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.resumeTimer(timerId, type);\r\n  } catch (error) {\r\n    console.error('Erreur lors de la reprise du timer:', error);\r\n  }\r\n};\r\n\r\n// Fonction stopTimer ajoutée (similaire à pauseTimer mais peut réinitialiser le timer)\r\nexport const stopTimer = (timerId: string, type: 'client' | 'task', reset: boolean = false): AppThunk => async (dispatch) => {\r\n  try {\r\n    // Mettre à jour l'état local\r\n    dispatch(updateTimerStatus({ timerId, type, isRunning: false }));\r\n\r\n    // Mettre à jour le timer actuel si c'est celui qui est en cours\r\n    dispatch(updateCurrentTimerIfMatches({ timerId, type, isRunning: false }));\r\n\r\n    // Si reset est true, réinitialiser la durée du timer\r\n    if (reset) {\r\n      // Cette partie nécessiterait un nouveau reducer pour réinitialiser la durée\r\n      // Pour l'instant, nous nous contentons d'arrêter le timer\r\n    }\r\n\r\n    // Appel API pour mettre à jour le timer sur le serveur\r\n    // Si vous n'avez pas de timerService, vous pouvez commenter cette ligne\r\n    // await timerService.stopTimer(timerId, type, reset);\r\n  } catch (error) {\r\n    console.error('Erreur lors de l\\'arrêt du timer:', error);\r\n  }\r\n};\r\n\r\nexport default timerSlice.reducer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}